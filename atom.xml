<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding 极简派</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-23T09:07:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xubing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如果让你去数羊 -- 谈分布式异步快照原理</title>
    <link href="http://yoursite.com/2017/01/23/asynchronousBarrierSnapshot/"/>
    <id>http://yoursite.com/2017/01/23/asynchronousBarrierSnapshot/</id>
    <published>2017-01-23T09:00:23.000Z</published>
    <updated>2017-01-23T09:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/01/23/asynchronousBarrierSnapshot/sheeps.jpg" alt="sheeps.jpg" title="">  
<p>当你第一次看断背山的时候,印象最深刻的是什么? 有没有可能是他们数羊的片段?? 哈哈,虽然肯定不是,但是今天的问题和数羊有关系. 如果一群羊都在跑, 你怎么数的清? (前提是没有标记)  </p>
<p>我先表扬自己一下, 因为在我看来,数羊是对于下面这个问题的一个绝妙的比喻.<br>可能你已经想到一个方法: 那就是给整个羊群照一张照片,然后自己拿着照片回家慢慢数. 这个方法用术语来表示就是你得到了一个全局快照(global snapshot).通过这个快照,你保留了一个可以恢复可以处理的稳定状态.<br>然而问题又来了,羊太多,一张照片照不全该怎么办?你怎么保证同时照几张照片呢?   </p>
<p>如果你说把羊全部打晕再数, 那我现在就打晕你.</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久不更新了,最近在公司过了一段读论文的日子,为了下一version项目的实时计算部分阅读了很多流计算资料. 包括Apache著名的四大流计算框架. Apache Storm, Spark streaming,Apache Flink,Samza. 以及google刚刚联合apache基金会成功孵化出的大数据处理统一编程模型 Apache Beam( 原型为Google的Dataflow.) </p>
<p>以下挑出一个有意思的点来分享. 这个是Apache Flink 消息传递机制保证和容错机制中确保每个消息被处理且仅被处理一次(所以不会出现消息丢失,同事又不会因为容错中消息重发而导致消息重复)的依赖原理.  </p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="无统一时钟"><a href="#无统一时钟" class="headerlink" title="无统一时钟"></a>无统一时钟</h3><img src="/2017/01/23/asynchronousBarrierSnapshot/bigben.jpg" alt="bigben.jpg" title="">  
<p>在计算机世界中,各个机器很难有一个统一的时钟来有统一的时间表示. 可能你会想我们人类世界中就可以保证大家对时间的认识一致.比如你和小明约定”我们明早8点的时候同时开始看某个电影”,你说的8点和小明说的8点我们都认为是一个时刻,即你们是可以实现”同时”的.   </p>
<p>这个其实是因为我们统一按照格林尼治的时间来做了一个统一. 但是让分布式系统中的每个机器都做到这样是很难的,或者说有一个总的master强制统一这个”同时”的开销是很大的.  </p>
<p>如果没有这个”同时”,我们就无法获得一个全局的状态(global state).</p>
<h3 id="全局状态-amp-稳定特征感应"><a href="#全局状态-amp-稳定特征感应" class="headerlink" title="全局状态 &amp; 稳定特征感应"></a>全局状态 &amp; 稳定特征感应</h3><p>而分布式系统中的很多问题都可以化为想要得到全局状态的问题.<br>比如,你想知道系统是否达到了稳定特征(stable property),譬如死锁问题,你需要这种稳定的状态来探测到系统已经发生死锁.  </p>
<p>稳定性的定义是这种状态会永久的持续下去,你可以想象在无阻力环境中的匀速运动或者静止状态. </p>
<p>稳定性感应可以用来做全局快照. 当稳定之后,比如羊群都停止移动或者同速同向平移,你可以在不同时刻照很多照片来合成一张”同时”的全局大照片.</p>
<h3 id="同步快照-amp-分布式异步快照"><a href="#同步快照-amp-分布式异步快照" class="headerlink" title="同步快照 &amp; 分布式异步快照"></a>同步快照 &amp; 分布式异步快照</h3><p>你想要在同一时刻保存系统状态,这个即是同步快照.   </p>
<p>分布式异步快照的主要思想是你通过协调,使得他们并不是在同一时刻保存快照,但是快照能够反应出系统数据的处理状态. 即一种”逻辑同步”, 这个是基于Chandy-Lamport算法,严谨地被证明在论文中.(reference中可查)</p>
<h2 id="流式计算中的exactly-once-语意容错机制"><a href="#流式计算中的exactly-once-语意容错机制" class="headerlink" title="流式计算中的exactly-once 语意容错机制"></a>流式计算中的exactly-once 语意容错机制</h2><p>消息传输保障机制分为三种:  </p>
<p>1.at most once</p>
<p>一条消息经过系统，由这条消息产生的后续tuple在各个处理节点最多会被处理一次，含义就是，出现故障时，不保证这条消息原本应该涉及的所有处理节点计算都顺利完成。</p>
<p>2.at least once</p>
<p>一条消息经过系统，由这条消息产生的后续tuple在各个处理节点至少会被处理一次，含义就是，出现故障时，系统能够识别并进行tuple重发，但是没办法判断是否之前该元组被成功处理完成了，因此可能会有重复处理的情况，对于某些改变外部状态的场景，会造成脏数据。</p>
<p>3.exactly once</p>
<p>一条消息经过系统，不管是否发生故障，由其产生的后续tuple，在所有处理节点上有且仅会被处理一次，这是最理想的情况，即使出现故障，也能符合正确的业务预期，但一般会带来比较大的性能开销。</p>
<p>因为做到exactly-once 有相对较大的性能开销,并且不是幂等的计算所必须,所以并非所有的流计算框架做到了这一点.  </p>
<p>相对于micro-batch底层实现的spark streaming,Apache Flink 便使用了分布式快照和检查点(checkpointing)机制来实现了exactly-once 的容错级别.  </p>
<p>Flink 进行周期性的全局快照(periodic global state)保存,从而在出现系统failure的时候,只要从上一次保存成功的全局快照中恢复每个节点的恢复状态,然后再使源数据节点从相应快照标记源数据节点重新开始处理即可恢复无措运行状态(Kafka可以做到这一点).</p>
<h2 id="Asynchronous-Barrier-Snapshot-ABS"><a href="#Asynchronous-Barrier-Snapshot-ABS" class="headerlink" title="Asynchronous Barrier Snapshot(ABS)"></a>Asynchronous Barrier Snapshot(ABS)</h2><p>同步快照有以下两种潜在的问题:   </p>
<ol>
<li>需要所有节点停止工作,即暂停了整个计算,这个必然影响数据处理效率和时效性.</li>
<li>需要保存所有节点/操作中的状态以及所有在传输中的数据(比如storm中的tuples),这个会消费大量的存储空间.</li>
</ol>
<p>轻量级的异步栅栏快照可以用来为数据流引擎提供容错机制,同时减小的存储空间需求.<br>因为ABS只需要保存一个无环拓扑中每个操作节点的处理状态(operator states).<br>Apache Flink 就使用了ABS的机制. </p>
<p>当运行可以分为几个阶段的时候,快照是可以不包含每个task节点间的通道状态的.</p>
<blockquote>
<p>Stages divide the injected data streams and all associated into a series of possible executions where all prior inputs and generated outputs have been fully processed.<br>The set of operator states at the end of a stage reflects the whole execution history, therefore, it can<br>be solely used for a snapshot. The core idea behind our<br>algorithm is to create identical snapshots with staged<br>snapshotting while keeping a continuous data ingestion.</p>
</blockquote>
<p>这段话太经典.  </p>
<p>可以通过切分源数据来划分阶段,每个集合的源数据也代表了其所需要的计算. 当上一个集合的输入数据以及输出都被完全处理,就代表上一个阶段结束了.   </p>
<p>所以当一个阶段结束时,操作节点的状态可以代表这整个个运行历史,从而快照可以仅仅依赖于operator states.</p>
<p>这些阶段可以通过周期性的在源头出插入一些栅栏(barrier)来划分. 这些栅栏起到了阶段的标记作用,然后跟着数据流通过整个数据处理pipeline,知道系统的sinks.  </p>
<p>全局状态在这个过程中,被增量地构建, 即当每个处理tast接收到对应id的栅栏的时候对自己的状态进行快照,而每个节点异步的快照共同组成了一个阶段(stage)</p>
<p>详细的过程可以见下图, Source1,2,3,4 在接到Master的checkpointing消息时,  </p>
<p>保存自己的消息消费状态,然后释放一个barrier(包含一个id标记).<br>当之后的task节点在接收到barrier时,停止处理下一条数据,马上对自己的状态进行快照并且持久化存储, 并且记录这次状态的id, 快照保存之后继续输出barrier并恢复数据梳理流程.   </p>
<p>当数据sinks收到所有barriers并且进行自身状态保存之后,也进行ack的checkpointing.</p>
<img src="/2017/01/23/asynchronousBarrierSnapshot/abs1.jpg" alt="abs1.jpg" title="">  
<p>论文算法如下:<br><img src="/2017/01/23/asynchronousBarrierSnapshot/abs2.jpg" alt="abs2.jpg" title="">  </p>
<p><strong>看到这里,你会数羊了吗?</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><p>Lightweight Asynchronous Snapshots for Distributed Dataflows<br>by Paris Carbone, Gyula Fora ,Stephan Ewen, Seif Haridi1, Kostas Tzoumas</p>
<p><a href="http://vinoyang.com/2016/05/22/flink-data-streaming-fault-tolerancer/" target="_blank" rel="external">http://vinoyang.com/2016/05/22/flink-data-streaming-fault-tolerancer/</a></p>
<p>Distributed Snapshots: Determining Global<br>States of Distributed Systems<br>K. MANI CHANDY<br>University of Texas at Austin<br>and<br>LESLIE LAMPORT<br>Stanford Research Institute </p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/01/23/asynchronousBarrierSnapshot/sheeps.jpg&quot; alt=&quot;sheeps.jpg&quot; title=&quot;&quot;&gt;  
&lt;p&gt;当你第一次看断背山的时候,印象最深刻的是什么? 有没有可能是他们数羊的片段?? 哈哈,虽然肯
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DistributedSystem" scheme="http://yoursite.com/tags/DistributedSystem/"/>
    
  </entry>
  
  <entry>
    <title>精疲力竭的骑行一天</title>
    <link href="http://yoursite.com/2017/01/09/bikingday/"/>
    <id>http://yoursite.com/2017/01/09/bikingday/</id>
    <published>2017-01-09T06:50:38.000Z</published>
    <updated>2017-01-09T06:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>记一天流水帐.   </p>
<p>杭州在经历连续将近一个月淅淅沥沥的风雨天气和似雾似霾的迷蒙混沌之后,在昨天终于放晴,而且几乎重现了G20时期的蓝天. 所以决定去骑行,路线是从仓前出发,经过西溪湿地去往西湖再返航.  </p>
<p>早晨吃了粥和包子,吃得很撑,所以中午不需要吃饭了.<br>我们大概中上午的时候出发, 绕小路前进,路上的景色就极好. [图],沿途还发现了几个新开不久的小公园.<br> <img src="/2017/01/09/bikingday/xihu1.jpg" alt="xihu1.jpg" title="">   </p>
<a id="more"></a>
 <img src="/2017/01/09/bikingday/xihu2.jpg" alt="xihu2.jpg" title="">  
<p>大概18公里后到达了西溪湿地,白天湿地里面有很多在锻炼或者散步的人们,但人也不算太多,绕行一圈后出发前往西湖, 灵隐路上几乎一路都是茶花,长得很像桃花,不过毕竟春天还没到. 也几乎一路都是景点,灵隐寺,龙井山,不过都没有深入,只是借路向前. 中途还穿越了一个大概三四公里的隧道, 一直有骑车运行回声的嗡嗡声, 有点压抑.   </p>
<p>终于到达了西湖,由于行人太多而且有些疲劳,下来推着车走.<br>西湖恢复了它应有的美貌.<br> <img src="/2017/01/09/bikingday/xihu4.jpg" alt="xihu4.jpg" title=""><br> <img src="/2017/01/09/bikingday/xihu7.jpg" alt="xihu7.jpg" title=""><br> <img src="/2017/01/09/bikingday/xihu8.jpg" alt="xihu8.jpg" title=""><br> <img src="/2017/01/09/bikingday/xihu11.jpg" alt="xihu11.jpg" title="">  </p>
<p>找了个长椅,吃苹果,喝瓶牛奶. 这时天色已经有些变暗了,已经大概三点半时候了,需要返航.<br> <img src="/2017/01/09/bikingday/xihu9.jpg" alt="xihu9.jpg" title="">  </p>
<p>返航的路上就是纯气力劳动了,愈来愈感到身体酸痛, 手臂,肩膀,pp和大腿.<br>实在没力气的时候就下来走一会儿继续骑,终于在七点多的时候回家, 精疲力竭,浑身酸痛,不过也很是开心.   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记一天流水帐.   &lt;/p&gt;
&lt;p&gt;杭州在经历连续将近一个月淅淅沥沥的风雨天气和似雾似霾的迷蒙混沌之后,在昨天终于放晴,而且几乎重现了G20时期的蓝天. 所以决定去骑行,路线是从仓前出发,经过西溪湿地去往西湖再返航.  &lt;/p&gt;
&lt;p&gt;早晨吃了粥和包子,吃得很撑,所以中午不需要吃饭了.&lt;br&gt;我们大概中上午的时候出发, 绕小路前进,路上的景色就极好. [图],沿途还发现了几个新开不久的小公园.&lt;br&gt; &lt;img src=&quot;/2017/01/09/bikingday/xihu1.jpg&quot; alt=&quot;xihu1.jpg&quot; title=&quot;&quot;&gt;   &lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Circular Array Loop</title>
    <link href="http://yoursite.com/2017/01/06/leetcode457/"/>
    <id>http://yoursite.com/2017/01/06/leetcode457/</id>
    <published>2017-01-06T03:47:35.000Z</published>
    <updated>2017-01-06T03:51:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode457-Circular-Array-Loop"><a href="#leetcode457-Circular-Array-Loop" class="headerlink" title="leetcode457. Circular Array Loop"></a>leetcode457. Circular Array Loop</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it’s negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be “forward” or “backward’.</p>
<p>Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -&gt; 2 -&gt; 3 -&gt; 0.</p>
<p>Example 2: Given the array [-1, 2], there is no loop.</p>
<p>Note: The given array is guaranteed to contain no element “0”.</p>
<p>Can you do it in O(n) time complexity and O(1) space complexity?</p>
<a id="more"></a>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">circularArrayLoop</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.size();</div><div class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; untouched;</div><div class="line">        <span class="keyword">bool</span> sign = nums[<span class="number">0</span>]&gt;<span class="number">0</span>; <span class="comment">//true for positive</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = untouched.begin();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">            untouched.insert(it,i);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!untouched.empty())&#123;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(untouched.find(idx)==untouched.end()&amp;&amp;idx!=last)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125; </div><div class="line">            <span class="keyword">if</span>(untouched.find(idx)==untouched.end()&amp;&amp;idx==last||sign!=(nums[idx]&gt;<span class="number">0</span>) )&#123;</div><div class="line">                idx = *untouched.begin();</div><div class="line">                sign = idx&gt;<span class="number">0</span>;</div><div class="line">                untouched.erase(untouched.begin());</div><div class="line">                last = idx;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">int</span> step = nums[idx];</div><div class="line">            untouched.erase(idx);</div><div class="line">            last = idx;</div><div class="line">            idx = (idx+step) % n;</div><div class="line">            idx = idx&gt;<span class="number">0</span>?idx:idx+n;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode457-Circular-Array-Loop&quot;&gt;&lt;a href=&quot;#leetcode457-Circular-Array-Loop&quot; class=&quot;headerlink&quot; title=&quot;leetcode457. Circular Array Loop&quot;&gt;&lt;/a&gt;leetcode457. Circular Array Loop&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it’s negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be “forward” or “backward’.&lt;/p&gt;
&lt;p&gt;Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 0.&lt;/p&gt;
&lt;p&gt;Example 2: Given the array [-1, 2], there is no loop.&lt;/p&gt;
&lt;p&gt;Note: The given array is guaranteed to contain no element “0”.&lt;/p&gt;
&lt;p&gt;Can you do it in O(n) time complexity and O(1) space complexity?&lt;/p&gt;
    
    </summary>
    
      <category term="OJ" scheme="http://yoursite.com/categories/OJ/"/>
    
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>批处理之外的世界 -- 实时流计算框架调研0x00</title>
    <link href="http://yoursite.com/2017/01/05/streaming1/"/>
    <id>http://yoursite.com/2017/01/05/streaming1/</id>
    <published>2017-01-05T13:38:35.000Z</published>
    <updated>2017-01-09T06:57:02.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/01/05/streaming1/leeches.jpg" alt="leeches.jpg" title="">  
<hr>
<p>最近看了些流计算方面的资料,尤其今天看到的Streaming 101&amp; 102 系列,颇有醍醐灌顶的感觉. 感觉之前听到的很多言论都属于夸夸其谈而不知其然,更莫论其所以然.</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当MapReduce横空出世的时候,凭借其强大的分布式批处理能力赢得了业界的广泛认可.<br>但慢慢的,我们有了新的需求.</p>
<ul>
<li>现在越来越多的业务需要非常实时的数据,比如说twitter/微信朋友圈,微博点赞等等,实时天气预测或者航班监测. Stream可以提供我们需要的短延时.</li>
<li>巨大的,快速增长的没有边界的数据集在当代发展环境中是非常普遍的,许多系统都是适应于这种无限扩充的数据集.</li>
<li>在数据到达的时候就进行处理,相当于把计算压力分布在不同的时间,帮助实现更加一致性和可预测的资源损耗</li>
</ul>
<h2 id="What-is-Streaming"><a href="#What-is-Streaming" class="headerlink" title="What is Streaming?"></a>What is Streaming?</h2><p>对于streaming有一个非常具体而简洁的解释: 一种为无限数据集设计的数据处理引擎.</p>
<blockquote>
<p>“ prefer to isolate the term streaming to a very specific meaning: a type of data processing engine that is designed with infinite data sets in mind. Nothing more. “</p>
</blockquote>
<h2 id="What-streaming-can-and-can’t-do"><a href="#What-streaming-can-and-can’t-do" class="headerlink" title="What streaming can and can’t do."></a>What streaming can and can’t do.</h2><h4 id="对于流计算的误区"><a href="#对于流计算的误区" class="headerlink" title="对于流计算的误区:"></a>对于流计算的误区:</h4><a id="more"></a>
<p>很长一段时间里,流计算系统都只被局限在提供 低延时,不够准确/推测性 的结果,通常要依赖结合更加强档的批处理系统来提供最终版本的正确结果.<br>有一个例子是Twitter的 Nathan Marz (creator of Storm) 提出的 Lambda Architecture.<br>Lambda Architecture 的基本思想是同时运行一个streaming system和一个batch system, 来进行本质上相同的计算.<br>Streaming system 负责提供低延时,不够准确的结果(无论是因为使用了近似算法,或者因为streaming system本身没有保证足够的正确性). 经过一段时间之后,batch system 运行并且提供数据的最终正式版本. 这在当时是非常绝妙而且成功的一个解决方案,它很好的平衡了batch system所能够保证的准确性和streaming system 所带来的轻巧的低延时.<br>然而 Lambda system 的维护非常棘手, 你需要去构建,提供并且维护两个独立版本的数据通道(pipeline), 之后在最终对两种结果进行merge.<br>所以 Tyler Akidau 指出一个设计良好的streaming system 实际上提供了批处理功能的超集.</p>
<blockquote>
<p>“Quite honestly, I’d take things a step further. I would argue that well-designed streaming systems actually provide a strict superset of batch functionality. “ -Tyler Akidau</p>
</blockquote>
<p>并且他提出流计算想要在这场游戏中赢得batch,只需要做到两点:</p>
<ol>
<li><p>Correctness- this getes you pairty with batch.<br>在本质来说,correctness boils down to consistent storage.即一致性的存储. (这点在事务与分布式事务中详细探讨)</p>
<p>Spark Streaming 很多年前第一次出现在大数据领域的时候,当时给黑暗的streaming 世界带来了一致性的一缕阳光.</p>
</li>
<li><p>Tools for reasoning about time — This gets you beyond batch.</p>
</li>
</ol>
<p>two domains of time:  </p>
<ul>
<li>Event time, 时间发生时刻 occurr</li>
<li>Processing time, 时间在系统中被观察到的时刻 observe</li>
</ul>
<p>最理想的情况是,时间发生时间和时间被观察处理的时间是相同的,即时间刚刚发生就被处理. 当然现实是残酷的, 二者的差距不仅不是0, 而且通常是许多因素的一个高可变函数,这些因素包括 输入的数据特征, 运行的引擎,以及硬件.   </p>
<ul>
<li>共享资源的局限性,比如说网络拥堵</li>
<li>软件原因,比如分布式系统的逻辑</li>
<li>数据本身的特征,包括key分布,吞吐量的变化, 或者无序性的变化.<br>(比如一个飞机上面的乘客,他们在飞机降落时刻关闭飞行模式).</li>
</ul>
<p>二者关系可见下图:  </p>
<img src="/2017/01/05/streaming1/figure1.jpg" alt="figure1.jpg" title="">  
<p>所以由于event occur time 和event process time关系的不可控性和易变性,会带来很多困难,比如说你根据event process time来把数据分块,那就并不能保证同一个even occur time区间发生的事件在处理时刻会落入一个时间窗口. 所以与其去追求一种特别完美的batch切分,不如去容忍这种不确定性, 只是我们要去量化这种”compieteness” 并且尽可能使它达到最优.</p>
<h2 id="Data-processing-patterns-常见的数据处理模式"><a href="#Data-processing-patterns-常见的数据处理模式" class="headerlink" title="Data processing patterns 常见的数据处理模式"></a>Data processing patterns 常见的数据处理模式</h2><blockquote>
<p>最激动人心的时刻来到了.</p>
</blockquote>
<h3 id="Bounded-data"><a href="#Bounded-data" class="headerlink" title="Bounded data."></a>Bounded data.</h3><p> 简单,直接.</p>
<h3 id="Unbounded-data-batch"><a href="#Unbounded-data-batch" class="headerlink" title="Unbounded data -batch"></a>Unbounded data -batch</h3><p>由于批量计算引擎先于流计算引擎诞生,所以最初的无限数据集是可以用batch engines来计算的. 道理很简单,我们把unbounded data 切分成一个有限数据集的集合,就可以用批量计算来处理.</p>
<h4 id="Fixed-windows"><a href="#Fixed-windows" class="headerlink" title="Fixed windows"></a>Fixed windows</h4><p>把数据源切分成等大的切片窗,之后将每个window作为分别独立的数据源进行处理. 比如对于日志的处理.<br>但可以想象的是,很多系统是有完整性的问题的(completeness), 比如同一个window里面的数据没有同时准备好? 他们产生于不同的无序时刻? 这就意味着你要做一些补偿,比如 将处理延迟到你确定所有需要的数据都收集齐全,或者在晚到的数据到达时再次处理这个window对应的batch.<br> <img src="/2017/01/05/streaming1/figure2.jpg" alt="figure2.jpg" title="">  </p>
<h4 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h4><p> batch如果用来处理更加复杂的windowing策略,比如session,就会暴露更多的缺点. Sessions通常被定义为一段用户活跃的时间段,而由于缺少活动而中断(比如你掉线了).  所以sessions会有很大风险被切分到不同的batch. 你可以通过增大batch的覆盖范围来减少这种split,但同时也会增大延迟.<br> <img src="/2017/01/05/streaming1/figure3.jpg" alt="figure3.jpg" title="">  </p>
<p>所以用批处理来处理unbounded data 是不理想的</p>
<h3 id="Unbounded-data-streaming"><a href="#Unbounded-data-streaming" class="headerlink" title="Unbounded data - streaming"></a>Unbounded data - streaming</h3><p>在现实世界中, 我们除了需要处理无限多的数据外,通常还有以下特点:  </p>
<ul>
<li>Highly unordered with respect to event times,即event times 非常无序. 因此需要在处理管道中有某种基于时间的shuffle.</li>
<li>Of varying event time skew,意思是说你无法保证在 Y时间之后一定会看到X时刻产生的数据.</li>
</ul>
<p>处理有这些特征的方法有四类:  </p>
<ul>
<li>Time-agnostic</li>
<li>Approximation</li>
<li>Windowing by processing time</li>
<li>Windowing by event time</li>
</ul>
<h4 id="Time-agnostic-与事件时间无关"><a href="#Time-agnostic-与事件时间无关" class="headerlink" title="Time-agnostic 与事件时间无关"></a>Time-agnostic 与事件时间无关</h4><ul>
<li><p>Filtering, 要对全部数据做某种过滤处理,所以who cares 这个数据是什么时候被产生或者观察到的.</p>
<img src="/2017/01/05/streaming1/figure4.jpg" alt="figure4.jpg" title="">  
</li>
<li><p>Inner-joins 两个数据源中任何一个element到达时刻进行join, 即这种处理逻辑中是没有时间因素的. 但是outer join是不一样的,当一个数据源中的某个element到达的时候,你并不知另一个会不会到达,所以你必须去设定某个timeout,这样就引入了时间因素,也就是某种类型的windowing.</p>
<img src="/2017/01/05/streaming1/figure5.jpg" alt="figure5.jpg" title="">  
</li>
</ul>
<h4 id="Approximation-algorithms-近似算法"><a href="#Approximation-algorithms-近似算法" class="headerlink" title="Approximation algorithms  近似算法"></a>Approximation algorithms  近似算法</h4><ul>
<li>比如 approximate Top-N, streaming K-means.</li>
<li>算法很复杂</li>
<li>逻辑有时间因素(事件处理时间)</li>
<li>有近似的局限性</li>
<li>overhead很低, 准确性要求不高时可以满足需求.</li>
</ul>
<h4 id="Windowing"><a href="#Windowing" class="headerlink" title="Windowing"></a>Windowing</h4><ul>
<li>含义是把一个数据集(无论bounded或者unbounded),切分成有限个数的块.</li>
<li><p>分成3类 见下图</p>
<img src="/2017/01/05/streaming1/windowing.jpg" alt="windowing.jpg" title="">  
</li>
<li><p>event time windows 的两个缺点:</p>
<ul>
<li>Buffering: 由于延长的时间生命期,对数据提出了更多的buffering要求. 不过好在持久化存储是多数数据处理最便宜的需求资源. 因为更多情况下,并不需要整个数据输入在buffer中 比如sum,average, 而是可以通过增量计算的,从而把中间结果存在持久存储中.</li>
<li>Completeness: 我们无法确定一个window的完整性,因为不知道某个数据什么时候到达.我们只能加入某些近似因素或者做补偿措施来保证严谨的完整性.</li>
</ul>
</li>
</ul>
<p>To be continued…    </p>
<h2 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h2><p>[1] MillWheel: Fault-Tolerant Stream Processing at<br>Internet Scale<br>[2] Say goodbye to batch<br>[3] The world beyond batch: Streaming 101<br>A high-level tour of modern data-processing concepts.<br>By Tyler Akidau August 5, 2015</p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/01/05/streaming1/leeches.jpg&quot; alt=&quot;leeches.jpg&quot; title=&quot;&quot;&gt;  
&lt;hr&gt;
&lt;p&gt;最近看了些流计算方面的资料,尤其今天看到的Streaming 101&amp;amp; 102 系列,颇有醍醐灌顶的感觉. 感觉之前听到的很多言论都属于夸夸其谈而不知其然,更莫论其所以然.&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当MapReduce横空出世的时候,凭借其强大的分布式批处理能力赢得了业界的广泛认可.&lt;br&gt;但慢慢的,我们有了新的需求.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现在越来越多的业务需要非常实时的数据,比如说twitter/微信朋友圈,微博点赞等等,实时天气预测或者航班监测. Stream可以提供我们需要的短延时.&lt;/li&gt;
&lt;li&gt;巨大的,快速增长的没有边界的数据集在当代发展环境中是非常普遍的,许多系统都是适应于这种无限扩充的数据集.&lt;/li&gt;
&lt;li&gt;在数据到达的时候就进行处理,相当于把计算压力分布在不同的时间,帮助实现更加一致性和可预测的资源损耗&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;What-is-Streaming&quot;&gt;&lt;a href=&quot;#What-is-Streaming&quot; class=&quot;headerlink&quot; title=&quot;What is Streaming?&quot;&gt;&lt;/a&gt;What is Streaming?&lt;/h2&gt;&lt;p&gt;对于streaming有一个非常具体而简洁的解释: 一种为无限数据集设计的数据处理引擎.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“ prefer to isolate the term streaming to a very specific meaning: a type of data processing engine that is designed with infinite data sets in mind. Nothing more. “&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;What-streaming-can-and-can’t-do&quot;&gt;&lt;a href=&quot;#What-streaming-can-and-can’t-do&quot; class=&quot;headerlink&quot; title=&quot;What streaming can and can’t do.&quot;&gt;&lt;/a&gt;What streaming can and can’t do.&lt;/h2&gt;&lt;h4 id=&quot;对于流计算的误区&quot;&gt;&lt;a href=&quot;#对于流计算的误区&quot; class=&quot;headerlink&quot; title=&quot;对于流计算的误区:&quot;&gt;&lt;/a&gt;对于流计算的误区:&lt;/h4&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="streaming" scheme="http://yoursite.com/tags/streaming/"/>
    
      <category term="real-time-processing" scheme="http://yoursite.com/tags/real-time-processing/"/>
    
  </entry>
  
  <entry>
    <title>日志系统 - 福尔摩斯的线索(一)</title>
    <link href="http://yoursite.com/2017/01/04/loggingSyestem1/"/>
    <id>http://yoursite.com/2017/01/04/loggingSyestem1/</id>
    <published>2017-01-04T07:16:51.000Z</published>
    <updated>2017-01-04T10:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/01/04/loggingSyestem1/fuermosi.jpeg" alt="fuermosi.jpeg" title="">  
<hr>
<blockquote>
<blockquote>
<p>Everything comes in cycles.</p>
</blockquote>
</blockquote>
<p>近来负责发布项目的一个二方包给服务调用方, 即写一个client包给别人使用.<br>然后发现一个很重要的问题是,我们的代码部署在别人的机器上,出了问题很难定位. 所以解决方案是我们要打出规范的日志,然后日志上云做出业务统计分析以及故障报警等.</p>
<h2 id="从门面说起-Facade-design-pattern"><a href="#从门面说起-Facade-design-pattern" class="headerlink" title="从门面说起 Facade design pattern"></a>从门面说起 Facade design pattern</h2><p>每个公司或者机构都有一个前台,比如银行, A想开户,B想找B1业务员询问基金信息. 如果没有前台,想象这个场景,每个人进去公司遍历查找,找到需要的人. 其间交错,冲突. 而如果有前台的化,每个人到前台说你要办理什么业务或者找什么人,前台小姐会把你自动转接给对应的业务人员,或者一个电话叫出你想要找的人.<br>这个就是门面的作用. 在设计模式中叫做Facade.<br>它有两个显而易见的好处:  </p>
<ol>
<li>对于客户端来说,它把系统内部复杂的组件隐藏封装起来,只向外暴露一个规范的高级接口. 降低了复杂性.</li>
<li>起到了解藕的作用,外部客户端和内部子系统之间的关系由Facade角色来实现,降低了系统的耦合.<img src="/2017/01/04/loggingSyestem1/facade.png" alt="facade.png" title="">   
</li>
</ol>
<a id="more"></a>  
<h2 id="挑选日志方案"><a href="#挑选日志方案" class="headerlink" title="挑选日志方案"></a>挑选日志方案</h2><h3 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h3><p>全称是Simple Logging Facade for Java. 就是这样一个对于各种日志框架的接口/抽象,比如java.util.logging,logback, log4j. </p>
<ul>
<li><p>具体的日志框架是在发布时做binding的.SLF4J 的发布版本包含许多 jar包文件,作为”SLF4J bindings”,每一个binding都对应着一种它支持的日志框架.   </p>
<ul>
<li>slf4j-log4j12-1.7.22.jar  对应log4j version 1.2</li>
<li>slf4j-jdk14-1.7.22.jar  Binding for java.util.logging, also referred to as JDK 1.4 logging</li>
<li><p>slf4j-nop-1.7.22.jar<br>Binding for NOP, silently discarding all logging.   </p>
</li>
<li><p>slf4j-simple-1.7.22.jar<br>Binding for Simple implementation, which outputs all events to System.err. Only messages of level INFO and higher are printed. This binding may be useful in the context of small applications.  </p>
</li>
<li><p>slf4j-jcl-1.7.22.jar<br>Binding for Jakarta Commons Logging. This binding will delegate all SLF4J logging to JCL.  </p>
</li>
<li><p>logback-classic-1.0.13.jar (requires logback-core-1.0.13.jar)<br>NATIVE IMPLEMENTATION There are also SLF4J bindings external to the SLF4J project, e.g. logback which implements SLF4J natively. Logback’s ch.qos.logback.classic.Logger class is a direct implementation of SLF4J’s org.slf4j.Logger interface. Thus, using SLF4J in conjunction with logback involves strictly zero memory and computational overhead.  </p>
</li>
</ul>
</li>
</ul>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>只需要在class path中放入slf4j api的jar包和对应binding的jar包(注意唯一性),在部署的时候,就会接入你想要的日志框架.</li>
<li>SLF4J 是不依赖于特定某一种类加载机制的. 每一个SLF4J binding是在编译时同对应的logging框架应链接的. 比如,slf4j-log4j12-1.7.22.jar binding在编译时同log4j绑定.</li>
<li><p>对应的binding和下层日志框架见下图.</p>
<img src="/2017/01/04/loggingSyestem1/bindings.png" alt="bindings.png" title="">   
</li>
<li><p>想要换日志系统,只要在class path中更新对应的binding,然后重启应用.</p>
</li>
<li>如果类路径上没有binding,slf4j-api会默认使用no-operation implementation, 忽略所有的日志请求. 而不会因为找不到org.slf4j.impl.StaticLoggerBinder class而扔出NoCalssDefFoundError.  </li>
</ul>
<h4 id="基本法则"><a href="#基本法则" class="headerlink" title="基本法则"></a>基本法则</h4><ul>
<li>embedded components 比如库或者框架不能声明依赖某一种SLF4J binding,而应该只依赖于slf4j-api.否则端用户就被迫依赖于某一种binding,这个和SLF4J的目的是相违背的.</li>
<li>而对于普通的项目(非libraries,非frameworks),得益于maven的间接依赖,对于某种日志系统都可以通过一个简单的依赖声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt; </div><div class="line">&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;1.0.13&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt; </div><div class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;1.7.22&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt; </div><div class="line">&lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;</div><div class="line">&lt;version&gt;1.7.22&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>slf4j-api.jar要和SLF4J binding的版本保持一直, 例如 slf4j-api-1.7.22.jar对应 slf4j-simple-1.7.22.jar, 而不能用slf4j-simple-1.5.5.jar,否则就会造成问题.<br>而不同version的 slf4j-api 不会发生冲突</p>
<h4 id="Mapped-Diagnostic-Context-MDC-支持"><a href="#Mapped-Diagnostic-Context-MDC-支持" class="headerlink" title="Mapped Diagnostic Context (MDC) 支持"></a>Mapped Diagnostic Context (MDC) 支持</h4><ul>
<li>MDC 是应用程序提供的k-v pairs,日志框架维护并且插入到日志信息中. </li>
<li>MDC 数据可以很大程度上帮助信息过滤或者触发某些行为.</li>
<li>SLF4J 支持MDC,如果下层日志框架(logback,log4j)也支持,LSF4J会把工作delegate给下层框架的MDC,而如果下层logging框架不支持(j.u.l),SLF4J会自己存储MDC数据,之后需要用户自己编码来获取.</li>
</ul>
<h4 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h4><p>如果你的系统里面已经使用了某种日志框架, SLF4J为你提供了平滑过度的桥接jar包.</p>
<ul>
<li>从Jakarta Commons Logging(JCL) 平滑迁移至SLF4J  <ul>
<li>jcl-over-slf4j.jar<br>只需要把commons-logging.jar 换成jcl-over-slf4j.jar</li>
<li>同时这个可以快速且永久地解决commons logging相关的类加载问题.</li>
<li>slf4j-jcl.jar  是SLF4J提供的JCL binding. 这个binding会把所有的logging calls 通过SLF4J delegate 给JCL.</li>
<li>避免无限循环. 不能同时使用 jcl-over-slf4j.jar 和 slf4j-jcl.jar,因为前者会使JCL 把选择日志系统的职责交给SLF4J 但是后者会造成SLF4J 把职责交给JCL,造成一个infinite loop.</li>
</ul>
</li>
<li>log4j-over-slf4j<br>  +log4j-over-slf4j.jar 和 slf4j-log4j12.jar  也不能同时使用</li>
<li>jul-to-slf4j bridge<ul>
<li>和上述两个模型 (reimplement log4j和commons-logging )不同的是, java.* namespace 下的package是不可替换的. 所以这里通过把LogRecord objects 翻译成对应的SLF4J equivalent. 这个翻译过程会带来很大的性能损失.</li>
<li>jul-to-slf4j.jar 和 slf4j-jdk14.jar 也不可以同时使用.<img src="/2017/01/04/loggingSyestem1/legacy.png" alt="legacy.png" title="">   
</li>
</ul>
</li>
</ul>
<h4 id="SLF4J-官方文档的一个SLF4J优点总结"><a href="#SLF4J-官方文档的一个SLF4J优点总结" class="headerlink" title="SLF4J 官方文档的一个SLF4J优点总结"></a>SLF4J 官方文档的一个SLF4J优点总结</h4><table>
<thead>
<tr>
<th>Advantage</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Select your logging framework at deployment time</td>
<td>The desired logging framework can be plugged in at deployment time by inserting the appropriate jar file (binding) on your class path.</td>
</tr>
<tr>
<td>Fail-fast operation</td>
<td>Due to the way that classes are loaded by the JVM, the framework binding will be verified automatically very early on. If SLF4J cannot find a binding on the class path it will emit a single warning message and default to no-operation implementation.</td>
</tr>
<tr>
<td>Bindings for popular logging frameworks</td>
<td>SLF4J supports popular logging frameworks, namely log4j, java.util.logging, Simple logging and NOP. The logback project supports SLF4J natively.</td>
</tr>
<tr>
<td>Bridging legacy logging APIs</td>
<td>The implementation of JCL over SLF4J, i.e jcl-over-slf4j.jar, will allow your project to migrate to SLF4J piecemeal, without breaking compatibility with existing software using JCL. Similarly, log4j-over-slf4j.jar and jul-to-slf4j modules will allow you to redirect log4j and respectively java.util.logging calls to SLF4J. See the page on Bridging legacy APIs for more details.</td>
</tr>
<tr>
<td>Migrate your source code</td>
<td>The slf4j-migrator utility can help you migrate your source to use SLF4J.</td>
</tr>
<tr>
<td>Support for parameterized log messages</td>
<td>All SLF4J bindings support parameterized log messages with significantly improved performance results.</td>
</tr>
</tbody>
</table>
<h3 id="log4j"><a href="#log4j" class="headerlink" title="log4j"></a>log4j</h3><p>log4j是一套快而灵活的日志框架.(APIs)<br>可以通过配置文件在运行时动态配置. 对于它而言,日志可以分成不同的需求层次,并且可以有不同的destination.</p>
<h4 id="3-main-components"><a href="#3-main-components" class="headerlink" title="3 main components:"></a>3 main components:</h4><ul>
<li>loggers: Responsible for capturing logging information</li>
<li>appenders:  Responsible for publishing logging information to vairious preferred destinations.</li>
<li>layouts: Responsible for formatting logging information in different styles.  </li>
</ul>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><h3 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h3><p>现在logback越来越占据了工业界的主要地位.</p>
<h2 id="日志采集系统架构"><a href="#日志采集系统架构" class="headerlink" title="日志采集系统架构"></a>日志采集系统架构</h2><p>几乎所有的平台和系统每天哦读会产生大量的日志.一般是流式数据.对日志的分析可以为我们提供很多业务发展和系统监控所需的数据,所以需要一个日志采集系统来架起一座链接应用系统和日志分析系统的桥梁. 同时由于日志多是流式数据,希望这些系统可以支持近实时和离线的日志分析系统. 最后需要有高扩展性.</p>
<p>####所有典型的日志系统具有三个基本组件:   </p>
<ul>
<li>agent: 封装数据源,将数据源中的数据发送给collector.</li>
<li>collector: 接收多个agent的数据,并进行汇总后导入后端的storage中.</li>
<li>storage: 中央存储系统,应该具有可扩展性和可靠性.</li>
</ul>
<p>####四个日志收集系统比较见下一篇博客  </p>
<ul>
<li>Facebook的scribe</li>
<li>Cloudera的Flume</li>
<li>LinkedIn的Kafka</li>
<li>Apache的Chukwa</li>
</ul>
<h4 id="reference"><a href="#reference" class="headerlink" title="reference:"></a>reference:</h4><p>m.blog.csdn.net/article/details?id=21240315<br>SLF4J官方文档 <a href="http://www.slf4j.org/manual.html" target="_blank" rel="external">http://www.slf4j.org/manual.html</a><br>log4j官方文档</p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/01/04/loggingSyestem1/fuermosi.jpeg&quot; alt=&quot;fuermosi.jpeg&quot; title=&quot;&quot;&gt;  
&lt;hr&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Everything comes in cycles.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;近来负责发布项目的一个二方包给服务调用方, 即写一个client包给别人使用.&lt;br&gt;然后发现一个很重要的问题是,我们的代码部署在别人的机器上,出了问题很难定位. 所以解决方案是我们要打出规范的日志,然后日志上云做出业务统计分析以及故障报警等.&lt;/p&gt;
&lt;h2 id=&quot;从门面说起-Facade-design-pattern&quot;&gt;&lt;a href=&quot;#从门面说起-Facade-design-pattern&quot; class=&quot;headerlink&quot; title=&quot;从门面说起 Facade design pattern&quot;&gt;&lt;/a&gt;从门面说起 Facade design pattern&lt;/h2&gt;&lt;p&gt;每个公司或者机构都有一个前台,比如银行, A想开户,B想找B1业务员询问基金信息. 如果没有前台,想象这个场景,每个人进去公司遍历查找,找到需要的人. 其间交错,冲突. 而如果有前台的化,每个人到前台说你要办理什么业务或者找什么人,前台小姐会把你自动转接给对应的业务人员,或者一个电话叫出你想要找的人.&lt;br&gt;这个就是门面的作用. 在设计模式中叫做Facade.&lt;br&gt;它有两个显而易见的好处:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于客户端来说,它把系统内部复杂的组件隐藏封装起来,只向外暴露一个规范的高级接口. 降低了复杂性.&lt;/li&gt;
&lt;li&gt;起到了解藕的作用,外部客户端和内部子系统之间的关系由Facade角色来实现,降低了系统的耦合.&lt;img src=&quot;/2017/01/04/loggingSyestem1/facade.png&quot; alt=&quot;facade.png&quot; title=&quot;&quot;&gt;   
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="logging" scheme="http://yoursite.com/tags/logging/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;情圣&gt;&gt;跨年之动态链接</title>
    <link href="http://yoursite.com/2017/01/01/dynamicLinking1/"/>
    <id>http://yoursite.com/2017/01/01/dynamicLinking1/</id>
    <published>2017-01-01T04:42:00.000Z</published>
    <updated>2017-01-03T07:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚去看电影跨年,<strong><em>血战钢锯岭</em></strong>没票了,只好随机找个片子看,不过结果还不错,<strong><em>情圣</em></strong>里面邀请了一众笑星,虽不高雅,但博大家一笑的目的算是达到了. </p>
<p>林语堂的<strong><em>论幽默</em></strong>中有一句话,” 人之智慧已启,对付各种问题之外,尚有余力,从容出之,遂有幽默”,指出幽默只是一种从容不迫的豁达态度. 事实确实如此,回顾近年的贺岁档中,愈是自黑丑恶,急急将窘迫慌张暴露给你的,往往俗不可耐,只生悲凉而无笑意,超哥自导的几部片子便毁于此. 而那些真正幽默的大师,都是在丰富人生阅历之中沉淀了无数智慧的,比如卓别林,崔永元.他们经历的太多,只是将某种从容的调逗点出,观众自会捧腹,而他们自己从来都不会笑.</p>
<p>今天来聊聊比较底层的动态链接.也因为有了动态链接,我们程序员能够更加从容的进行程序开发和发布. 节约静态链接中因为重复载入静态/共享库而浪费的磁盘和内存,同时也避免了程序中某个模块的升级而带来的整个程序的重新链接和发布,并且由于可以在运行时动态加载模块而增加了程序的扩展性.<br><a id="more"></a>  </p>
<h3 id="背景知识补充"><a href="#背景知识补充" class="headerlink" title="背景知识补充"></a>背景知识补充</h3><p>程序的运行过程包括: ( 见下图 )<br><img src="/2017/01/01/dynamicLinking1/build.png" alt="build.png" title="">   </p>
<h3 id="动态链接-vs-静态链接"><a href="#动态链接-vs-静态链接" class="headerlink" title="动态链接 vs 静态链接"></a>动态链接 vs 静态链接</h3><p>它的基本思想是,程序像静态链接一样可以被拆成相互比较独立的模块,然而不同的是,在程序运行时刻才链接在一起形成一个完整的程序,而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件.</p>
<p>具体到过程则是,前面部分, OS会读取可执行文件的头部(header),检查文件的合法性,然后从header中的” Program Header” 中读取每个 Segment的虚拟地址, 文件地址和属性,并将他们映射到进程虚拟空间的相应位置.<br>可以用这个命令来读header.    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$readelf</span> <span class="_">-l</span> Lib.so</div></pre></td></tr></table></figure>
<p>但是在静态链接下,之后OS会将控制权交给可执行文件的入口地址,而动态链接下会将控制权交给动态链接器.(因为这个时候可执行文件中还有很多对于外部共享文件的引用处于无效地址状态,还没有和共享文件中的实际位置链接起来.)  </p>
<p>当动态链接器取得控制权后,开始执行自身一系列初始化操作,然后根据当前环境参数对饿执行文件进行动态链接工作,动态链接工作完成后,将控制权再转交给可执行文件入口,程序开始正式执行.</p>
<p>所以一句话总结动态链接的本质就是</p>
<blockquote>
<blockquote>
<p>将链接从装载前推迟到了装载时.   </p>
</blockquote>
</blockquote>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>有如下源文件 Program1.c, Program2.c  Lib.c 和Lib.h.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*Program1.c*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Lib.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    foobar(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="comment">/*Program2.c*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Lib.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    foobar(<span class="number">2</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;  </div><div class="line">    </div><div class="line"><span class="comment">/* Lib.c*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    pringf(<span class="string">"Printing from Lib.so %d\n"</span>,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*Lib.h*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIB_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIB_H</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> <span class="_">-f</span>PIC -shared -o Lib.so Lib.c //生成Lib.so</div><div class="line"></div><div class="line"><span class="variable">$gcc</span> -o Program1 Program1.c ./链接器Lib.so</div><div class="line"><span class="variable">$gcc</span> -o Program2 Program2.c ./Lib.so</div></pre></td></tr></table></figure>
<p>在静态链接中,Program1.o 会和Lib.o一起被链接生成可执行文件 Program1.  </p>
<p>而动态链接中, Lib.o没有被链接进来,但是为什么命令行中有Lib.so的参与? 因为它提供了完整的符号信息来指示每个symbol到底是静态符号还是动态符号. 如果是一个静态符号,链接器会按照静态链接的规则将Program1.o中的foobar地址引用重定位,但是如果是定义在动态共享对象中的函数,链接器就会将这个符号的引用标记为一个动态链接的符号,而不对它进行地址重定位,把这个过程留到装载时再进行.</p>
<p>还有一个区别是,动态共享对象在编译时候是不知道最终装载地址的,因为静态链接只要装载一个可执行文件,而动态链接要装载很多不同的”动态单元”,包括可执行对象和许多共享对象. 操作系统会按照当前地址空间的空闲情况,将一块足够大小的虚拟地址动态分给相应的共享对象.</p>
<p>那么问题来了,这许多”动态单元”装载地址怎么处理?<br>我们不同进程间想最大限度的共用代码,而且每次装载地址都是未知的.<br>针对需求的两个方案就是</p>
<ol>
<li><p>装载时重定位<br> 当模块的装载地址确定,即目标地址确定,那么系统就对程序中所有的绝对地址引用进行重定位. 比如函数foobar位于代码段的其实地址是0x100, 当模块被装载到0x10000000,(假设代码段位于模块开头),那么foobar的地址就是0x10000100.之后系统遍历模块中的重定位表,把所有对foobar的地址引用都重定位到0x10000100.</p>
</li>
<li><p>地址无关代码技术<br>在上述装载时重定位中的一个未解决问题是.我们希望模块中共享的指令部分不因为装载的地址发生变化而变化.而映射进虚拟进程空间之后,经历重定位,不同进程间就没法使用同一份指令. 解决办法依旧是一样的, 把可变的部分抽离出来.即把指令中哪些需要被修改的地方分离出来跟数据部分放在一起,因为数据是每个进程有一个独立副本的.</p>
<p>针对四种不同的地址引用都可以实现地址无关性:    </p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>指令跳转,函数调用</th>
<th>数据访问</th>
</tr>
</thead>
<tbody>
<tr>
<td>模块内部</td>
<td>(1) 相对跳转和调用</td>
<td>(2)相对地址访问</td>
</tr>
<tr>
<td>模块外部</td>
<td>(3) 间接跳转和调用(GOT)</td>
<td>(4) 间接访问(GOT)</td>
</tr>
</tbody>
</table>
<h3 id="步骤和实现"><a href="#步骤和实现" class="headerlink" title="步骤和实现"></a>步骤和实现</h3><h4 id="鸡生蛋-蛋生鸡-动态链接器bootstrap"><a href="#鸡生蛋-蛋生鸡-动态链接器bootstrap" class="headerlink" title="鸡生蛋,蛋生鸡 - 动态链接器bootstrap"></a>鸡生蛋,蛋生鸡 - 动态链接器bootstrap</h4><p>因为动态链接器自己就是一个共享对象(蛋),OS同样通过映射的方式把它加载进进程的地址空间中.而其它共享对象都有赖于动态链接器来完成重定位工作和链接与装载.(鸡)  </p>
<p>那么为了打破鸡生蛋,蛋生鸡的无线循环,动态链接器中有一段bootstrap的代码. 动态链接器本身不可以依赖于其它共享对象,锁需要的全局和金泰变量重定位工作由自己完成.而且使用PIC模式(地址无关代码)编译的共享对象对于模块内部的函数调用也采用和调用外部函数一样的方式,即使用GOT/PLT的方式. 所以GOT重定位/PIT之前,这些都不可用. </p>
<p>这段自力更生,自强不息的bootstrap代码是这样的,当操作系统将进程控制权交给动态链接器时,先找到它自己的GOT,然后第一个入口为”.dynamic”段的偏移地址,通过其中的信息,可以活得动态链接器本身的重定位表和符号表等,从而可以得到动态链接器本身的重定位入口,先将他们全部重定位.  这里开始便可以开始使用自己的全局变量和静态变量.</p>
<p>Glibc 2.6.1 源代码中 elf/rtld.c中在bootstrap代码的末尾写道:</p>
<blockquote>
<blockquote>
<p>Now life is sane,we can call functions and access global data. Set up to use the operating system facilities,and find out from the operating system’s program loader where to find the program header table in core. Put the rest of _dl_start into a separate function ,that way the compiler cannot put accesses to the GOT before ELF_DYNAMIC_RELOCATE.</p>
</blockquote>
</blockquote>
<h4 id="装载共享对象"><a href="#装载共享对象" class="headerlink" title="装载共享对象"></a>装载共享对象</h4><p>链接器从.dynamic 中DT_NEEDED里面获取改可执行对象(或共享对象)所依赖的共享对象,将所有名字放入一个装载集合中,然后从集合中取出一个,找到相应的文件后打开,读取ELF file header 和.dynamic segment,将它相应的代码段和数据段映射到进程空间.如果这个ELF shared object 还依赖与其它共享对象, 则也把其名字放入装载集合.循环知道所有依赖的共享对象都被装载. </p>
<p>这个装载过程相当与一个依赖图的遍历过车工,比较常见使用广度优先遍历.</p>
<h4 id="重定位和初始化"><a href="#重定位和初始化" class="headerlink" title="重定位和初始化"></a>重定位和初始化</h4><p>链接器开始遍历可执行文件和每个共享对象的重定位表,将他们的GOT/PLT 的每个需要重定位的未知进行修正.<br>并且会对有”.init” 段的共享队形进行初始化.</p>
<h4 id="权利移交"><a href="#权利移交" class="headerlink" title="权利移交"></a>权利移交</h4><p>在做完这些工作之后,所需要的共享对象也都已经装载并且链接完成了,链接器可以将权利转交给程序的入口并开始执行. 功成身退.</p>
<p>没有涉及到的问题和细节下次再续. To be continued…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨晚去看电影跨年,&lt;strong&gt;&lt;em&gt;血战钢锯岭&lt;/em&gt;&lt;/strong&gt;没票了,只好随机找个片子看,不过结果还不错,&lt;strong&gt;&lt;em&gt;情圣&lt;/em&gt;&lt;/strong&gt;里面邀请了一众笑星,虽不高雅,但博大家一笑的目的算是达到了. &lt;/p&gt;
&lt;p&gt;林语堂的&lt;strong&gt;&lt;em&gt;论幽默&lt;/em&gt;&lt;/strong&gt;中有一句话,” 人之智慧已启,对付各种问题之外,尚有余力,从容出之,遂有幽默”,指出幽默只是一种从容不迫的豁达态度. 事实确实如此,回顾近年的贺岁档中,愈是自黑丑恶,急急将窘迫慌张暴露给你的,往往俗不可耐,只生悲凉而无笑意,超哥自导的几部片子便毁于此. 而那些真正幽默的大师,都是在丰富人生阅历之中沉淀了无数智慧的,比如卓别林,崔永元.他们经历的太多,只是将某种从容的调逗点出,观众自会捧腹,而他们自己从来都不会笑.&lt;/p&gt;
&lt;p&gt;今天来聊聊比较底层的动态链接.也因为有了动态链接,我们程序员能够更加从容的进行程序开发和发布. 节约静态链接中因为重复载入静态/共享库而浪费的磁盘和内存,同时也避免了程序中某个模块的升级而带来的整个程序的重新链接和发布,并且由于可以在运行时动态加载模块而增加了程序的扩展性.&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="computerSystem" scheme="http://yoursite.com/tags/computerSystem/"/>
    
  </entry>
  
  <entry>
    <title>迷茫的引擎之递归查询</title>
    <link href="http://yoursite.com/2016/12/31/recursiveQuery/"/>
    <id>http://yoursite.com/2016/12/31/recursiveQuery/</id>
    <published>2016-12-31T03:46:26.000Z</published>
    <updated>2017-01-03T07:18:04.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2016/12/31/recursiveQuery/tworoads.jpg" alt="tworoads.jpg" title="">   
<p>今天去做一个数据清洗的任务,在执行数据变更的时候遇到了一个奇怪的问题.<br>类似于这种SQL (隐去公司业务相关性)<br>我是犬类爱好者,所以假如我有一个记载各种狗的id和名称的表<br>table <code>lovelydog</code><br><a id="more"></a>  </p>
<table>
<thead>
<tr>
<th>dogId</th>
<th>name</th>
<th>description</th>
<th>intelligenceRank</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Labrador Retriever(拉布拉多)</td>
<td>cheerful,gentle friendly,intelligent</td>
<td>7</td>
</tr>
<tr>
<td>2</td>
<td>German Shepherd (德牧羊)</td>
<td>courageous,intelligent,loyal,watchful</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>Golden Retriever (金毛)</td>
<td>Intelligent,Kind,Friendly,Confident</td>
<td>4</td>
</tr>
<tr>
<td>4</td>
<td>Bulldog (沙皮)</td>
<td>Frendly,docile,Willful,Gregarious</td>
<td>77</td>
</tr>
<tr>
<td>5</td>
<td>Beagle(比格)</td>
<td>Gentle,Intelligent,Even Tempered,Determined</td>
<td>72</td>
</tr>
</tbody>
</table>
<pre><code class="sql">
<span class="keyword">delete</span> <span class="keyword">from</span> <span class="string">`lovelydog`</span> <span class="keyword">where</span> intelligenceRank 
<span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">max</span>(intelligenceRank)<span class="keyword">from</span> <span class="string">`lovelydog`</span> )
</code></pre>
<p>非常简单,我从表中剔除最笨的一种狗狗.<br>但是执行数据变更的时候报出 MYSQL error “You can’t specify target table X for update in FROM clause”.<br>为什么流程不和我们想象的一样顺化,先从表中找出智力的最小值,然后把智力为该值的狗狗从表中delete.<br>google了一番发现了如下几个没有思考过的问题.</p>
<h3 id="Recursive-Query-查询递归"><a href="#Recursive-Query-查询递归" class="headerlink" title="Recursive Query 查询递归"></a>Recursive Query 查询递归</h3><p>Mysql 引擎不允许我们在做DML(delete/insert/update)的时候在subquery里面去reference当前table. 这一点在mysql 的手册UPDATE下面最后一行有指出.”You cannot update a table and select from the same table in a subquery.”<br>为什么呢?   </p>
<p>因为这里有一个query cycle.<br>在stackoverflow上有如下解释</p>
<blockquote>
<p>Think about the semantics. Either MySQL has to keep a copy of the table before the update started, or the inner query might use data that has already been updated by the query as it’s in progress. Neither of these side-effects is necessarily desirable, so the safest bet is to force you to specify what will happen using an extra table. – siride    </p>
<p>This is because your update could be cyclical… what if updating that record causes something to happen which made the WHERE condition FALSE? You know that isn’t the case, but the engine doesn’t. There also could be opposing locks on the table in the operation.<br>所以这是一个reasonable design decision.   </p>
</blockquote>
<p>引擎在两难的困境不知道怎么做,所以把这个顺序决定权交在了user手中.</p>
<h3 id="解决-创造新的视图"><a href="#解决-创造新的视图" class="headerlink" title="解决:创造新的视图"></a>解决:创造新的视图</h3><p>这个问题的解决方式是一个简单的变通,我们在subquery中创建一个新的视图,从而force engine来首先进行subquery.</p>
<pre><code class="sql">
<span class="keyword">delete</span> <span class="keyword">from</span> <span class="string">`lovelydog`</span> <span class="keyword">where</span> intelligenceRank 
<span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">max</span>(intelligenceRank)<span class="keyword">from</span> <span class="string">`lovelydog`</span> )<span class="keyword">AS</span> X )
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2016/12/31/recursiveQuery/tworoads.jpg&quot; alt=&quot;tworoads.jpg&quot; title=&quot;&quot;&gt;   
&lt;p&gt;今天去做一个数据清洗的任务,在执行数据变更的时候遇到了一个奇怪的问题.&lt;br&gt;类似于这种SQL (隐去公司业务相关性)&lt;br&gt;我是犬类爱好者,所以假如我有一个记载各种狗的id和名称的表&lt;br&gt;table &lt;code&gt;lovelydog&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>你所以为,未必是事实 -论事务与分布式事务(一)</title>
    <link href="http://yoursite.com/2016/12/28/distributedTransaction1/"/>
    <id>http://yoursite.com/2016/12/28/distributedTransaction1/</id>
    <published>2016-12-28T03:26:14.000Z</published>
    <updated>2017-01-03T07:16:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/island.jpg" alt=""></p>
<p>近期看了三个比较印象深刻的电影, 我把他们归结为同一类型,这就是今天的主题– 你所以为,你所目睹,你所相信,未必是事实.</p>
<p>其一是刚刚实至名归获得奥斯卡小金人的莱昂纳多主演的<strong><em>禁闭岛</em></strong>,当年泰坦尼克号里面的Jack也算迷倒众生的形象了, 纵然大叔颜值不复当年,可小李子靠着<strong><em>荒野猎人</em></strong>里面”辛苦的”演技(比如熊斗,吃生肉,爬雪地)终于在无数个擦肩而过之后将小金人收入囊中.<strong><em>禁闭岛</em></strong>中的演技你也可大呼高超, 足足到电影结尾你或者猛然惊醒,或者即便怀疑多个细节也未必可知真相. 在这里就不做剧透了,看过的必知我在说什么,没看过的元旦也可以宅在家里好好玩味一番.<br><a id="more"></a>  </p>
<p>其二是推理悬疑豆瓣高分榜的不可或缺之作 <strong><em>致命ID</em></strong>, 在美国偏僻地方的一个汽车旅馆发生的死亡故事. 故事背后的原理其实并不陌生, 也许大家都知道多重人格这种心理现象. 具有这种精神特质的人会演化出多个从性格到技能完全不同的多种人格, 而这几个人格又会随着外界环境刺激或者自身感情变化来回轮换. 你所看到的汽车旅馆的七个人的死亡际会,其实只是一个多重人格的人的人格间角逐争斗的外围映射.</p>
<p>其三是美国电影 <strong><em>不明身份</em></strong>,讲述一个杀手在和杀手伙伴一起实施行动过程中意外发生车祸而失忆,忘记自己的真实身份,只记得并且坚信自己是当初为了展开杀手行动而伪造的一个身份, 而最终变成了行动的反对和组织者的故事,在不断的求证求真的过程中, 他知道了自己的真实身份,也恢复了部分记忆,但他最终选择了不再做一个杀手,成功保护了险些被暗杀的发现粮食增产方法的植物学家,造福了人类社会.</p>
<p>这三个电影都在结尾才昭示真相,让观众恍然大悟而意犹未尽. 其实本质运用的手法都是–视角不同,或者说维度不同. 片子的观众被安排在了主人公的视角里只能看到这种维度的世界,也就是你所目睹和你所以为的世界, 而这个视角下的世界未必是真实的世界. 倘若你拥有了上帝视角,那么这几部片子对你而言就不再是悬疑片,而成为了枯燥的纪录片. </p>
<p>当这种视角的限制和变换给你带来乐趣,给作家带来写作工具的时候, 它在计算机领域也给我们带来了一些问题. </p>
<p>化学史上很长一段时间内分子是不可再分的,人们像笃信地心说一样笃信分子是最小的结构. 但当越来越多的实验现象用这种理论无法解释的时候,人们才开始探求并打破这个认识,认识到比分子更小的还有原子..(当然比原子小的还有夸克,但是这里不再继续深究)</p>
<p>当我们用任何一种编程语言敲出一行语言的时候,比如最简单的增一   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//int a=0;</span></div><div class="line">a++;</div></pre></td></tr></table></figure>
<p>我们从一个天真的程序员视角会想这不是一个简单的原子操作吗,给a加一, 无论你loop多少次,比如100次, 她的结果肯定是100. 难道有什么问题吗?<br>假设如果你在做这个给a加一的操作,莱昂纳多也在做这个动作[当然他不会的,他还在忙着泡超模].那么结果是2吗? 不一定! 结果可能是2, 也可能是1.这看起来像是一个悬疑片吗?<br>真相也只需要你换一个视角. </p>
<p><strong>why?</strong> </p>
<p>加一的这个操作对于计算机来说并不是一个最小粒度的原子性的操作.<br>它可以被拆解为:  </p>
<ul>
<li>从存储将a的值读到寄存器</li>
<li>寄存器+1</li>
<li>将寄存器的值写回a的地址</li>
</ul>
<p>所以如果你在读出a=0后, 在发生3之前,莱昂纳多进来也读取了a=0,然后你们分别做2 的操作然后写回地址,那么结果就是1. 莱昂纳多和你的操作是没有相互独立的,你们分别可见对方的中间态,而且每个独立人的操作是非原子性的.  </p>
<p>如果你想避免这种状态的化,可以给这个过程加锁,当你操作a地址的时候,拒绝来昂那多操作a的值,那么你们两个的操作被迫就编程了线性发生.(你不会想在操作银行账户的时候还和来昂那多见个面吧..) </p>
<p>加锁即是把你们共享的状态或者数据进行一个访问限制, 以实现排他性从而实现安全操作.   </p>
<p>这种竞争状态还有很多其它场景,比如对于数据库来说, 大家习以为常的insert/delete/update其实都并不是原子性的, 它都要先对数据进行一个读操作,然后进行一个写操作.</p>
<p>对于这种当你希望”你所以为,必是事实”的情况,官方的定义是这是一个事务单元[transaction]. 就是你希望指令按照你所希望的顺序执行,不会出现你意向不到的结果. 便是要实现事务一致性.</p>
<p>今天的闲话扯的太多了,时间有限,匆匆以事务ACID的解释结尾吧.</p>
<p><strong>ACID:</strong></p>
<ul>
<li>原子性（Atomicity）:事务要么成功执行（提交），要么所有的动作都不发生（回滚）。</li>
<li>一致性(Consistency）：事务产生一致的结果并且保证程序的完整性约束。</li>
<li>隔离性（Isolation）：事务执行时的中间状态对其它事务是不可见的。此外事务应该表现为连续执行，即使实际是并发执行的。两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。</li>
<li>持久性（Durability）：提交事务的结果是永久性的（即使是灾难性的故障）</li>
</ul>
<p>关于这个宏大的话题下次接着讨论.</p>
<p>PS 今天[12.28]是我的生日.<br>新开通这个公众号当是我送给自己的一个生日礼物.可以祝我生日快乐~ :P</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/island.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;近期看了三个比较印象深刻的电影, 我把他们归结为同一类型,这就是今天的主题– 你所以为,你所目睹,你所相信,未必是事实.&lt;/p&gt;
&lt;p&gt;其一是刚刚实至名归获得奥斯卡小金人的莱昂纳多主演的&lt;strong&gt;&lt;em&gt;禁闭岛&lt;/em&gt;&lt;/strong&gt;,当年泰坦尼克号里面的Jack也算迷倒众生的形象了, 纵然大叔颜值不复当年,可小李子靠着&lt;strong&gt;&lt;em&gt;荒野猎人&lt;/em&gt;&lt;/strong&gt;里面”辛苦的”演技(比如熊斗,吃生肉,爬雪地)终于在无数个擦肩而过之后将小金人收入囊中.&lt;strong&gt;&lt;em&gt;禁闭岛&lt;/em&gt;&lt;/strong&gt;中的演技你也可大呼高超, 足足到电影结尾你或者猛然惊醒,或者即便怀疑多个细节也未必可知真相. 在这里就不做剧透了,看过的必知我在说什么,没看过的元旦也可以宅在家里好好玩味一番.&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Knowledge" scheme="http://yoursite.com/tags/Knowledge/"/>
    
  </entry>
  
  <entry>
    <title>从一本书的启迪开始新年计划</title>
    <link href="http://yoursite.com/2016/12/27/newBornToMaster/"/>
    <id>http://yoursite.com/2016/12/27/newBornToMaster/</id>
    <published>2016-12-27T02:52:35.000Z</published>
    <updated>2017-01-03T07:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016还剩最后几天,大部分人都有制定新年计划的习惯,纵使在年末你总是发现划去的可能都不足1/3.但这并没有阻碍过人们定下新年计划时的决心. </p>
<p>刚刚步入工作有一些迷茫点,觉得学生思维有一定的局限性.而今天很幸运的发现了一本 <em>Pragmatic Thinking and Learning -Refactor Your Wetware.</em> 这是写给程序员的一本思维指导书,但是不要担心你不是程序员,因为本书的所有方法和原理都是通用的,任何职业的人都可以在其中找到共鸣.</p>
<p>下面分享书中一些重要的理论观点和可执行方案. 其中参杂一些我的个人感受. Credit to  Andy Hunt. [The author of the book]</p>
<p>每个步入职场的人大概都想过如何从新人-到专家,尤其是每个程序员的职业规划的主线.Andy 提到的两个中心便是.  </p>
<ul>
<li>随着不断的成长和适应,人们需要改变自己的习惯和方法.  </li>
<li>成为一名专家的关键因素:理解情景和利用直觉.<a id="more"></a>  
</li>
</ul>
<h2 id="从新手到专家的历程"><a href="#从新手到专家的历程" class="headerlink" title="从新手到专家的历程"></a>从新手到专家的历程</h2><p><strong>key ideas</strong>:   </p>
<ul>
<li>理论分为 事件理论,和构建理论.dreyfus模型是构建理论. </li>
<li>模式匹配 是一种很重要的技能.关于这一点我也深有体会,每一次的联想,举一反三,甚至到用的每一个比喻,隐喻,背后的支撑都是模式匹配.</li>
<li>脑皮层竞争,DIY脑部手术. 持续使用和实践的技能会逐渐占据统治地位,大脑中就会有更多部位被关联起来.大脑会把资源用于做的最多的事情. “不使用就会失去”. 可能这就是音乐家不断联系音阶的原因,类似于动态刷新RAM. 想做一名更好的程序员吗? 那就多编码,深思熟虑,专注时间.</li>
</ul>
<p><strong>可执行方案</strong>:　　</p>
<ul>
<li>坚持晨写至少两周</li>
<li>培养快速的洞察能力.寻找不相关事务之间的联系.</li>
<li>阅读一些有别于平常的东西</li>
<li>尝试不同类型的电影,音乐,咖啡等.</li>
<li>逆向思维</li>
<li>点几道你没有吃过的菜</li>
</ul>
<h3 id="DEBUG-YOUR-BRAIN"><a href="#DEBUG-YOUR-BRAIN" class="headerlink" title="DEBUG YOUR BRAIN"></a>DEBUG YOUR BRAIN</h3><ul>
<li>认知偏见:思维如何被误导</li>
<li>时代影响:同代人的选择如何影响你</li>
<li>个性倾向:个性如何影响思维.</li>
<li>硬件故障: 大脑较老的区域如何抑制较聪明的区域.</li>
</ul>
<h3 id="HOW-TO-MAKE-YOUR-PLAN"><a href="#HOW-TO-MAKE-YOUR-PLAN" class="headerlink" title="HOW TO MAKE YOUR PLAN"></a>HOW TO MAKE YOUR PLAN</h3><ul>
<li>用SMART方式来制定目标.</li>
<li>具体的,可度量的,可实现的,相关的,时间可控的.</li>
<li>goal =&gt; objectives(任务)</li>
<li>比如具体的: 我想学会Erlang=&gt;用Erlang写一个可以动态生成内容的web服务器.</li>
</ul>
<h3 id="做你自己的知识投资组合"><a href="#做你自己的知识投资组合" class="headerlink" title="做你自己的知识投资组合"></a>做你自己的知识投资组合</h3><ul>
<li>把技术和才干看作一个知识投资组合.</li>
<li>管理知识投资的要点</li>
<li>制定具体的计划</li>
<li>多样性</li>
<li>主动投资</li>
<li>定期投资 (比如你在一周的交通时间用来读一本书)</li>
<li>即时反馈或者做信息输出或者分享</li>
</ul>
<h3 id="使用你的原生学习模式"><a href="#使用你的原生学习模式" class="headerlink" title="使用你的原生学习模式"></a>使用你的原生学习模式</h3><ul>
<li><p>你的学习方法加速器</p>
<ul>
<li>主动阅读和总结书面材料的更好方式</li>
<li>使用思维导图 探索和发现模式的关系(不要觉得这是个形式或者鸡汤,我在大四学习Principles of programming language 的时候使用过这种方法自学,效果是比其它课的概念都记得清楚而且作笔记更快更有趣)</li>
<li>以教代学</li>
</ul>
</li>
<li><p>主动读书的方法: </p>
<ul>
<li>SQ3R方法</li>
<li>调查(Survey):扫描目录和每章总结,得出总结看法.</li>
<li>问题(Question):记录所有问题</li>
<li>阅读(Read): 阅读全部内容</li>
<li>复述(Recite): 总结,作笔记,用自己的话来复述</li>
<li>回顾(Review): 重读,扩展笔记,和别人讨论.<br>这项技术的第一个有用方面是主动性. 人们不再是一个随机地捡起一本书阅读,而不管记住或者没有记住多少内容.这种技术是一种更周到,更自觉,更有意识的方法.</li>
</ul>
</li>
<li>思维导图的制作方法:<ul>
<li>准备一张白纸</li>
<li>中间加标题,可以哟更圆圈况起来</li>
<li>对于每一个主要的子标题,用圆圈引出线,加上标题</li>
<li>重复执行其它层次的节点</li>
<li>对于其它的单独事实或者想法,从合适的标题引出线,添加标题<h3 id="假装成功"><a href="#假装成功" class="headerlink" title="假装成功"></a>假装成功</h3>这个方法很多地方都提到过,可以帮助你先体验一下你所能达到的目标和达到之后的感觉. 有利于你最终实现目标</li>
</ul>
</li>
</ul>
<h3 id="管理思维"><a href="#管理思维" class="headerlink" title="管理思维"></a>管理思维</h3><ul>
<li>好问题是没有答案的. 它不是一个需要拧紧的螺栓,而是一颗种下的种子,由它可以收获一片思想的绿洲. - John Anthony Ciardi 美国诗人和评论家.</li>
<li>管理注意力<ul>
<li>我们生活在信息丰富的时代,但往往过犹不及,过多的饿信息却导致了知识和注意力的匮乏.置身于应接不暇的信息中, 很容易市区思考的重心.与其游荡在信息的高速公路中,不如主动地管理你的思维.</li>
<li>管理你所能接收到的信息.在恰当的时候获取恰当的信息,不被无关紧要的细节迷惑,也不措施任何绝妙的线索.</li>
</ul>
</li>
<li>管理知识<ul>
<li>大脑之外的支持工具会成为你大脑思维的一部分.</li>
<li>利用外部信息系统,建立一种分布式知识存储体系.</li>
<li>通过wiki组织你的伟大想法,你会得到更多的great ideas.</li>
<li>计算机有一种超越我们思维结构的独特优势,它能够轻松的交换情景.</li>
<li>context switch 耗能很高, 被打断之后平均需要20分钟才能调回来.  </li>
</ul>
</li>
</ul>
<h4 id="可执行方案"><a href="#可执行方案" class="headerlink" title="可执行方案"></a>可执行方案</h4><p>一些建议:  </p>
<ul>
<li>开始承担责任,不要还怕问”为什么”,或者”你怎么知道的”</li>
<li>挑两件帮助i维持情景,免受干扰的事,立即实施.</li>
<li>创建一个实用的知识投资计划,设定SMART目标.</li>
<li>弄清楚你所属专业领域中所处的未知(从新手到专家)和你期望的未知.</li>
<li>时间</li>
<li>允许犯更多错误</li>
<li>携带一个笔记本,涂鸦,做思维导图,记笔记,让思想自由流动</li>
<li>在私人wiki上记录你感兴趣的事情</li>
<li>开始写博客.为你读过的书写评论. 阅读更多书,你会有更多科协的东西.</li>
<li>可以让散步成为你每天生活的一个部分</li>
<li>启动一个读书小组</li>
</ul>
<blockquote>
<p>Last word,<br>自由的代价是永远保持警惕.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016还剩最后几天,大部分人都有制定新年计划的习惯,纵使在年末你总是发现划去的可能都不足1/3.但这并没有阻碍过人们定下新年计划时的决心. &lt;/p&gt;
&lt;p&gt;刚刚步入工作有一些迷茫点,觉得学生思维有一定的局限性.而今天很幸运的发现了一本 &lt;em&gt;Pragmatic Thinking and Learning -Refactor Your Wetware.&lt;/em&gt; 这是写给程序员的一本思维指导书,但是不要担心你不是程序员,因为本书的所有方法和原理都是通用的,任何职业的人都可以在其中找到共鸣.&lt;/p&gt;
&lt;p&gt;下面分享书中一些重要的理论观点和可执行方案. 其中参杂一些我的个人感受. Credit to  Andy Hunt. [The author of the book]&lt;/p&gt;
&lt;p&gt;每个步入职场的人大概都想过如何从新人-到专家,尤其是每个程序员的职业规划的主线.Andy 提到的两个中心便是.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随着不断的成长和适应,人们需要改变自己的习惯和方法.  &lt;/li&gt;
&lt;li&gt;成为一名专家的关键因素:理解情景和利用直觉.
    
    </summary>
    
      <category term="思考" scheme="http://yoursite.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="职业规划" scheme="http://yoursite.com/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>偷梁换柱 - copy 和 move</title>
    <link href="http://yoursite.com/2016/03/29/saodiseng20160329/"/>
    <id>http://yoursite.com/2016/03/29/saodiseng20160329/</id>
    <published>2016-03-29T06:52:07.000Z</published>
    <updated>2017-01-04T13:24:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你怎么交换两个变量值"><a href="#你怎么交换两个变量值" class="headerlink" title="你怎么交换两个变量值?"></a>你怎么交换两个变量值?</h2><p>这大概是每个初学编程的人都会遇到的一个问题. 你的第一反应一定是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function">T <span class="title">tmp</span><span class="params">(a)</span></span>;</div><div class="line">	a = b;</div><div class="line">	b = tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单来说就是当你需要交换两杯水的时候,你需要借助第三个杯子.</p>
<p>考虑一下它的中间开销.</p>
<ol>
<li>T tmp(a).你利用copy constructor重新构造了一个对象tmp,并且复制了a.</li>
<li>用 a复制了b</li>
<li>用b 复制了a</li>
</ol>
<p>如果copy的代价很高的化…</p>
<p>然而有没有不复制的办法来交换两个变量的值?<br>有一个经典的告诫大家学会分享的萧伯纳名言:</p>
<blockquote>
<blockquote>
<p>“如果你有一个苹果，我有一个苹果，彼此交换，那么，每个人只有一个苹果；<br>如果你有一个思想，我有一个思想，彼此交换，我们每个人就有了两个思想，甚至多于两个思想。”</p>
</blockquote>
</blockquote>
<p>我们不是要说分享,是要说拷贝和移动的关系.如果人手一台3D打印机,可能每人也有两个苹果吧. 但你看到了,拷贝的过程,是要经历生产的开销. 即使是思想的拷贝,如果它足够复杂晦涩,那相比也要死不少脑细胞.</p>
<p>在C++中,有一个还比较古老的操作符叫move,就起到了这种移动的作用.<br>下面的一段引用来说明copy和move的关系.<br><a id="more"></a></p>
<blockquote>
<blockquote>
<p>Hitherto, copying has been the only means for transferring a state from one object to another (an object’s state is the collective set of its non-static data members’ values). Formally, copying causes a target object t to end up with the same state as the source s, without modifying s. For example, when you copy a string s1 to s2, the result is two identical strings with the same state as s1.<br>Notwithstanding the conceptual difference between copying and moving, there’s a practical difference too: Move operations tend to be faster than copying because they transfer an existing resource to a new destination, whereas copying requires the creation of a new resource from scratch. The efficiency of moving can be witnessed among the rest in functions that return objects by value.</p>
</blockquote>
</blockquote>
<p>所以交换两个值可以写作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp;a, T&amp; b)</span></span></div><div class="line">&#123;</div><div class="line">	T tmp = move(a);<span class="comment">//此时a时效了,内部的数据被move到了tmp中)</span></div><div class="line">	a = move(b);</div><div class="line">	b = move(tmp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好处是减少构造一些不必要的对象,节省了对象的空间消耗和construction 和destruction 的过程.    </p>
<h2 id="函数返还一个container"><a href="#函数返还一个container" class="headerlink" title="函数返还一个container"></a>函数返还一个container</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; doubleValues (<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; new_values;</div><div class="line">    new_values.reserve(v.size());</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> itr = v.begin(), end_itr = v.end(); itr != end_itr; ++itr )</div><div class="line">    &#123;</div><div class="line">        new_values.push_back( <span class="number">2</span> * *itr );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> new_values;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ )</div><div class="line">    &#123;</div><div class="line">        v.push_back( i );</div><div class="line">    &#125;</div><div class="line">    v = doubleValues( v );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是又一个例子.<br>这里new_values 除了在doubleValues() 里面构造了一个,在你把函数返回按结果作为右值赋给v的时候又复制了一遍.之前的new_values 作为function 的local value自然会之后被回收. 但如果直接可以把它移动出来减少拷贝开销该有多好.<br>move() comes to rescue again!</p>
<p>这里就要提到左值和右值的区别.<br>左值可以被看作一个有名字的value/object, 而右值是一个无名的临时value.   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x+(y*z); <span class="comment">// A C++ expression that produces a temporary</span></div></pre></td></tr></table></figure>
<p>这个临时构造的value在你到达分号的时候就灰飞烟灭了.<br>那怎么做到移动而不拷贝呢?  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> x;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">getRvalueInt</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// notice that it's fine to move a primitive type--remember, std::move is just a cast</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move( x );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;你怎么交换两个变量值&quot;&gt;&lt;a href=&quot;#你怎么交换两个变量值&quot; class=&quot;headerlink&quot; title=&quot;你怎么交换两个变量值?&quot;&gt;&lt;/a&gt;你怎么交换两个变量值?&lt;/h2&gt;&lt;p&gt;这大概是每个初学编程的人都会遇到的一个问题. 你的第一反应一定是&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; T&amp;gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T&amp;amp; a, T&amp;amp; b)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(a)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	a = b;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	b = tmp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单来说就是当你需要交换两杯水的时候,你需要借助第三个杯子.&lt;/p&gt;
&lt;p&gt;考虑一下它的中间开销.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;T tmp(a).你利用copy constructor重新构造了一个对象tmp,并且复制了a.&lt;/li&gt;
&lt;li&gt;用 a复制了b&lt;/li&gt;
&lt;li&gt;用b 复制了a&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果copy的代价很高的化…&lt;/p&gt;
&lt;p&gt;然而有没有不复制的办法来交换两个变量的值?&lt;br&gt;有一个经典的告诫大家学会分享的萧伯纳名言:&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“如果你有一个苹果，我有一个苹果，彼此交换，那么，每个人只有一个苹果；&lt;br&gt;如果你有一个思想，我有一个思想，彼此交换，我们每个人就有了两个思想，甚至多于两个思想。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们不是要说分享,是要说拷贝和移动的关系.如果人手一台3D打印机,可能每人也有两个苹果吧. 但你看到了,拷贝的过程,是要经历生产的开销. 即使是思想的拷贝,如果它足够复杂晦涩,那相比也要死不少脑细胞.&lt;/p&gt;
&lt;p&gt;在C++中,有一个还比较古老的操作符叫move,就起到了这种移动的作用.&lt;br&gt;下面的一段引用来说明copy和move的关系.&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++11" scheme="http://yoursite.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>一次不懈的速率优化-3Sum</title>
    <link href="http://yoursite.com/2015/11/03/5optimization/"/>
    <id>http://yoursite.com/2015/11/03/5optimization/</id>
    <published>2015-11-03T02:28:19.000Z</published>
    <updated>2017-01-04T13:06:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于2Sum"><a href="#关于2Sum" class="headerlink" title="关于2Sum"></a>关于2Sum</h1><p>Two sum是一个很简单的问题,给定一个乱序列和一个target,找到两个数的和等于target.<br>只要先sort然后用首尾两个pointers 反向逼近直到找到所求就可以了.可以找到所有符合要求的tuple,这里简化为解决第一个遇到的符合条件的tuple,找到全部组合见下面3sum.</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line">这里是题目的要求:</div><div class="line">Given an array of integers, find two numbers such that they add up to a specific target number.</div><div class="line"></div><div class="line">The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</div><div class="line"></div><div class="line">You may assume that each input would have exactly one solution.</div><div class="line">'''</div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :type target: int</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">2</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        backup = nums[:]    </div><div class="line">        list.sort(nums)</div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = len(nums)<span class="number">-1</span></div><div class="line">        <span class="keyword">while</span> i&lt;j:</div><div class="line">            <span class="keyword">if</span> (nums[i]+nums[j])&lt;target:</div><div class="line">                i=i+<span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> (nums[i]+nums[j])&gt;target: </div><div class="line">                j=j<span class="number">-1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> nums[i]==nums[j]:</div><div class="line">                    index1 = backup.index(nums[i])</div><div class="line">                    backup.remove(nums[i])</div><div class="line">                    <span class="keyword">return</span> [index1+<span class="number">1</span>,backup.index(nums[j])+<span class="number">2</span>]    </div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    index1 = backup.index(nums[i])+<span class="number">1</span></div><div class="line">                    index2 = backup.index(nums[j])+<span class="number">1</span></div><div class="line">                    <span class="keyword">return</span> [min(index1,index2),max(index1,index2)]</div></pre></td></tr></table></figure>
<h1 id="3sum-摘掉面具"><a href="#3sum-摘掉面具" class="headerlink" title="3sum-摘掉面具"></a>3sum-摘掉面具</h1><p>Three sum 与two sum类似,是数组中找出所有三个数的组合加和为target.<br>它穿了一层马甲,我们摘掉他的面具, 将3Sum转化为解决了的2Sum问题,只要从0 loop 到 length-2 (设为x),对剩余数组找target-x,就转化成了twoSum.  </p>
<p>不同的一点是要找到全部组合,同时要排重.</p>
<p>我的第一个解法是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        result = []    </div><div class="line">        list.sort(nums)    </div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            target = -nums[x]</div><div class="line">            rs = self.twoSum(nums[x+<span class="number">1</span>:],target)</div><div class="line">            <span class="keyword">if</span>(rs!=[]):</div><div class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> rs:</div><div class="line">                    <span class="keyword">if</span> [nums[x]]+r <span class="keyword">not</span> <span class="keyword">in</span> result:</div><div class="line">                        result.append([nums[x]]+r)</div><div class="line">        <span class="keyword">return</span> result</div><div class="line">        </div><div class="line">            </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self,nums,target)</span>:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = len(nums)<span class="number">-1</span></div><div class="line">        tmprs = []</div><div class="line">        flag = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span>(i&lt;j):</div><div class="line">            <span class="keyword">if</span> nums[i]+nums[j]&lt;target:</div><div class="line">                i = i+<span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> nums[i]+nums[j]&gt;target:</div><div class="line">                j = j<span class="number">-1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> [nums[i],nums[j]] <span class="keyword">not</span> <span class="keyword">in</span> tmprs: </div><div class="line">                    tmprs.append( [nums[i],nums[j]])</div><div class="line">                i=i+<span class="number">1</span></div><div class="line">                j=j<span class="number">-1</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">        <span class="keyword">return</span> tmprs</div></pre></td></tr></table></figure>
<p>trivial. 然而速率却很慢,在使用python的人群中只beats about 30%.<br>Could stand? No.<br>开始优化.</p>
<h1 id="while-True-optimize"><a href="#while-True-optimize" class="headerlink" title="while True: optimize()"></a>while True: optimize()</h1><h2 id="排重优化0x00"><a href="#排重优化0x00" class="headerlink" title="排重优化0x00"></a><strong>排重优化0x00</strong></h2><p>第一个想法是先从排除重复结果上来优化.<br>在这个解法之前我试用完全得到包含重复的结果来2 pass 排重 会造成time exceed.因为这个排重过程已经是O(n^2)<br>这里用了 not in the list 来排重,O(n)的time complexity.想到可以用查询时间为O(1)的set来排重,然而list是unhashable的.</p>
<p>我尝试了化成string然后hash</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">strset = set()     </div><div class="line"><span class="keyword">if</span> str(tmp) <span class="keyword">not</span> <span class="keyword">in</span> strset:</div><div class="line">	result.append(tmp)</div><div class="line">	strset.add(str(tmp))</div><div class="line">	</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        hashset = set()    </div><div class="line">        result = []    </div><div class="line">        list.sort(nums)    </div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            target = -nums[x]</div><div class="line">            rs = self.twoSum(nums[x+<span class="number">1</span>:],target)</div><div class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rs:</div><div class="line">                <span class="keyword">if</span> str([nums[x]]+r) <span class="keyword">not</span> <span class="keyword">in</span> hashset:</div><div class="line">                    result.append([nums[x]]+r)</div><div class="line">                    hashset.add(str([nums[x]]+r))</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> result</div><div class="line">        </div><div class="line">            </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self,nums,target)</span>:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = len(nums)<span class="number">-1</span></div><div class="line">        tmprs = []</div><div class="line">        <span class="keyword">while</span>(i&lt;j):</div><div class="line">            <span class="keyword">if</span> nums[i]+nums[j]&lt;target:</div><div class="line">                i = i+<span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> nums[i]+nums[j]&gt;target:</div><div class="line">                j = j<span class="number">-1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> [nums[i],nums[j]] <span class="keyword">not</span> <span class="keyword">in</span> tmprs: </div><div class="line">                    tmprs.append( [nums[i],nums[j]])</div><div class="line">                i=i+<span class="number">1</span></div><div class="line">                j=j<span class="number">-1</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">        <span class="keyword">return</span> tmprs</div></pre></td></tr></table></figure>
<p>然而并未卵,之后怀疑是转化为str太慢吗,tuple结果一样.<br>…<br>被没有显著的变化.</p>
<h2 id="排重优化0x01"><a href="#排重优化0x01" class="headerlink" title="排重优化0x01"></a><strong>排重优化0x01</strong></h2><p>要减小排重带来的overhead. 上面的思路一直是在得到搜索结果之后再排重,那么一个反向的想法是我应该在搜索之前就排重,想如果第一个数是一样的化,之后twoSum的结果也是相同的,那么这次twoSum 的搜索就是没有意义的,于是我记录之前第一个数prev,就继续找下一个起点  </p>
<p>改进如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        result = []    </div><div class="line">        list.sort(nums)</div><div class="line">        </div><div class="line">        prev = <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            target = -nums[x]</div><div class="line">            <span class="keyword">if</span> target == prev:</div><div class="line">                <span class="keyword">continue</span> </div><div class="line">            prev = target</div><div class="line">            rs = self.twoSum(nums[x+<span class="number">1</span>:],target)</div><div class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rs:</div><div class="line">                result.append([nums[x]]+r)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result</div><div class="line">        </div><div class="line">            </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self,nums,target)</span>:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = len(nums)<span class="number">-1</span></div><div class="line">        tmprs = []</div><div class="line">        <span class="keyword">while</span>(i&lt;j):</div><div class="line">            <span class="keyword">if</span> nums[i]+nums[j]&lt;target:</div><div class="line">                i = i+<span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> nums[i]+nums[j]&gt;target:</div><div class="line">                j = j<span class="number">-1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> [nums[i],nums[j]] <span class="keyword">not</span> <span class="keyword">in</span> tmprs: </div><div class="line">                    tmprs.append( [nums[i],nums[j]])</div><div class="line">                i=i+<span class="number">1</span></div><div class="line">                j=j<span class="number">-1</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">        <span class="keyword">return</span> tmprs</div></pre></td></tr></table></figure>
<p>这样就可以减调每次的线性排查   if [nums[x]]+r not in result:</p>
<p>performance有了进步,达到了50%左右.  </p>
<h2 id="排重优化0x02"><a href="#排重优化0x02" class="headerlink" title="排重优化0x02"></a><strong>排重优化0x02</strong></h2><p>在外围即第一个数事先排重之后,在twoSum搜索中也应该事先排重,<br>之前的loop是i++,j– 来前进一步,然而很有可能依然有重复值.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        result = []    </div><div class="line">        list.sort(nums)</div><div class="line">        </div><div class="line">        prev = <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            target = -nums[x]</div><div class="line">            <span class="keyword">if</span> target == prev:</div><div class="line">                <span class="keyword">continue</span> </div><div class="line">            prev = target</div><div class="line">            rs = self.twoSum(nums[x+<span class="number">1</span>:],target)</div><div class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rs:</div><div class="line">                result.append([nums[x]]+r)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result</div><div class="line">        </div><div class="line">            </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self,nums,target)</span>:</span></div><div class="line">        i = <span class="number">0</span></div><div class="line">        j = len(nums)<span class="number">-1</span></div><div class="line">        tmprs = []</div><div class="line">        <span class="keyword">while</span>(i&lt;j):</div><div class="line">            <span class="keyword">if</span> nums[i]+nums[j]&lt;target:</div><div class="line">                i = i+<span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> nums[i]+nums[j]&gt;target:</div><div class="line">                j = j<span class="number">-1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                     </div><div class="line">                <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]==nums[i+<span class="number">1</span>]:</div><div class="line">                    i =i+<span class="number">1</span></div><div class="line">                <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]==nums[j<span class="number">-1</span>]:    </div><div class="line">                    j =j<span class="number">-1</span></div><div class="line">                    </div><div class="line">                tmprs.append( [nums[i],nums[j]])    </div><div class="line">                i=i+<span class="number">1</span></div><div class="line">                j=j<span class="number">-1</span></div><div class="line">                <span class="keyword">continue</span></div><div class="line">        <span class="keyword">return</span> tmprs</div></pre></td></tr></table></figure>
<p>nice, 速率达到了60%多.</p>
<p>接下来该优化哪里呢?<br>我开始到处放空枪,看有没有机会打下一只鸟.  </p>
<h2 id="0x03-去除method-call"><a href="#0x03-去除method-call" class="headerlink" title="0x03 去除method call"></a><strong>0x03 去除method call</strong></h2><p>我开始想在dynamic programming中反复recruisive call 造成的overhead. 于是我省去另建函数twoSum.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        result = []    </div><div class="line">        list.sort(nums)</div><div class="line">        </div><div class="line">        prev = <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            target = -nums[x]</div><div class="line">            <span class="keyword">if</span> target == prev:</div><div class="line">                <span class="keyword">continue</span> </div><div class="line">            prev = target</div><div class="line">            nums1 = nums[x+<span class="number">1</span>:]</div><div class="line">            i = <span class="number">0</span></div><div class="line">            j = len(nums1)<span class="number">-1</span></div><div class="line">            tmprs = []</div><div class="line">            <span class="keyword">while</span>(i&lt;j):</div><div class="line">                <span class="keyword">if</span> nums1[i]+nums1[j]&lt;target:</div><div class="line">                    i = i+<span class="number">1</span></div><div class="line">                <span class="keyword">elif</span> nums1[i]+nums1[j]&gt;target:</div><div class="line">                    j = j<span class="number">-1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums1[i]==nums1[i+<span class="number">1</span>]:</div><div class="line">                        i =i+<span class="number">1</span></div><div class="line">                    <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums1[j]==nums1[j<span class="number">-1</span>]:    </div><div class="line">                        j =j<span class="number">-1</span></div><div class="line">                    tmprs.append( [nums1[i],nums1[j]])    </div><div class="line">                    i=i+<span class="number">1</span></div><div class="line">                    j=j<span class="number">-1</span></div><div class="line">                    <span class="keyword">continue</span></div><div class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> tmprs:</div><div class="line">                result.append([nums[x]]+r)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>一声空响.  </p>
<p>每次function被放在stack上,用后即delete, 和recuisive call 造成的overhead无法相提并论.  </p>
<h2 id="0x04-去除list-copy"><a href="#0x04-去除list-copy" class="headerlink" title="0x04 去除list copy"></a><strong>0x04 去除list copy</strong></h2><p>突然意识到我每次都copy了后段list来传入twoSum,造成了很大浪费,应该只传入原list,只要改变index就可以了,这样才不违背在最开始时候就进行sort的初衷.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        result = []    </div><div class="line">        list.sort(nums)</div><div class="line">        </div><div class="line">        prev = <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            target = -nums[x]</div><div class="line">            <span class="keyword">if</span> target == prev:</div><div class="line">                <span class="keyword">continue</span> </div><div class="line">            prev = target</div><div class="line">            i = x+<span class="number">1</span></div><div class="line">            j = len(nums)<span class="number">-1</span></div><div class="line">            tmprs = []</div><div class="line">            <span class="keyword">while</span>(i&lt;j):</div><div class="line">                <span class="keyword">if</span> nums[i]+nums[j]&lt;target:</div><div class="line">                    i = i+<span class="number">1</span></div><div class="line">                <span class="keyword">elif</span> nums[i]+nums[j]&gt;target:</div><div class="line">                    j = j<span class="number">-1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]==nums[i+<span class="number">1</span>]:</div><div class="line">                        i =i+<span class="number">1</span></div><div class="line">                    <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]==nums[j<span class="number">-1</span>]:    </div><div class="line">                        j =j<span class="number">-1</span></div><div class="line">                    tmprs.append( [nums[i],nums[j]])    </div><div class="line">                    i=i+<span class="number">1</span></div><div class="line">                    j=j<span class="number">-1</span></div><div class="line">                    <span class="keyword">continue</span></div><div class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> tmprs:</div><div class="line">                result.append([nums[x]]+r)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>速率达到了80%-90%</p>
<h2 id="0x05-last-shot"><a href="#0x05-last-shot" class="headerlink" title="0x05 last shot"></a><strong>0x05</strong> last shot</h2><p>统一了外部的事先排重,这里的一个教训是对于有序数列来说,排重是很有优势的,应该利用order事先排除,loop until 一个不同的值出现.  </p>
<p>而我之前的做法其实是浪费已排序的这个已知信息资源.  </p>
<p>对于未消逝的变量,根本没有必要每次记录history.</p>
<p>改进如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[List[int]]</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        result = []    </div><div class="line">        list.sort(nums)</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</div><div class="line">            target = -nums[x]</div><div class="line">            <span class="keyword">if</span> x&gt;<span class="number">0</span> <span class="keyword">and</span> target == -nums[x<span class="number">-1</span>]:</div><div class="line">                <span class="keyword">continue</span> </div><div class="line">            i = x+<span class="number">1</span></div><div class="line">            j = len(nums)<span class="number">-1</span></div><div class="line">            <span class="keyword">while</span>(i&lt;j):</div><div class="line">                <span class="keyword">if</span> nums[i]+nums[j]&lt;target:</div><div class="line">                    i = i+<span class="number">1</span></div><div class="line">                <span class="keyword">elif</span> nums[i]+nums[j]&gt;target:</div><div class="line">                    j = j<span class="number">-1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[i]==nums[i+<span class="number">1</span>]:</div><div class="line">                        i =i+<span class="number">1</span></div><div class="line">                    <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> nums[j]==nums[j<span class="number">-1</span>]:    </div><div class="line">                        j =j<span class="number">-1</span></div><div class="line">                    result.append([nums[x],nums[i],nums[j]])    </div><div class="line">                    i=i+<span class="number">1</span></div><div class="line">                    j=j<span class="number">-1</span></div><div class="line">                    <span class="keyword">continue</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>bingo! 速率达到了 python人群的 <strong>90%</strong> 左右.</p>
<h2 id="0x06-Not-the-end"><a href="#0x06-Not-the-end" class="headerlink" title="0x06 Not the end"></a><strong>0x06 Not the end</strong></h2><p>这一定不是终结,还没有想到进一步的优化方式,先用一个法则来自我安慰:</p>
<h2 id="Hill’s-law"><a href="#Hill’s-law" class="headerlink" title="Hill’s law"></a><strong>Hill’s law</strong></h2><pre><code>Simple and Dumb can be better  
</code></pre><p>…lol</p>
<p>Never stop optimizing until you give out your all.<br>However, don’t forget the Hill’s law.            </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于2Sum&quot;&gt;&lt;a href=&quot;#关于2Sum&quot; class=&quot;headerlink&quot; title=&quot;关于2Sum&quot;&gt;&lt;/a&gt;关于2Sum&lt;/h1&gt;&lt;p&gt;Two sum是一个很简单的问题,给定一个乱序列和一个target,找到两个数的和等于target.&lt;br&gt;只要先sort然后用首尾两个pointers 反向逼近直到找到所求就可以了.可以找到所有符合要求的tuple,这里简化为解决第一个遇到的符合条件的tuple,找到全部组合见下面3sum.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="performanceOptimization" scheme="http://yoursite.com/tags/performanceOptimization/"/>
    
  </entry>
  
  <entry>
    <title>常回C看看</title>
    <link href="http://yoursite.com/2015/10/30/reviewC/"/>
    <id>http://yoursite.com/2015/10/30/reviewC/</id>
    <published>2015-10-30T15:40:28.000Z</published>
    <updated>2017-01-04T13:24:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常回C看看"><a href="#常回C看看" class="headerlink" title="常回C看看."></a>常回C看看.</h1><p>当你整天写python, ruby 等脚本语言 甚至一些越来越像lambda calculus的declarative language时候.( 以及同样有CG机制的不讨很多人喜欢的Java时), 你可能越来越像一个称职的”software” engineer instead of a hardware engineer. 足够抽象的语言将你从同机器的傻瓜式繁琐对话中解放出来,变成同人类或者智能机器的对话.将更多的精力集中在算法和模式思考上.<br>操作系统变得看不见摸不着,不需要再自己处理memory allocation 和memory collection, 不需要精心计算how much memory i need. 远观的确美,但其实也少了些xie玩的乐趣.</p>
<p>随着C++11 Java8都开始引入风靡的lambda时,别忘记老当益壮的C老爹. </p>
<p>常回C看看. </p>
<p>这个月12号是C语言之父<a href="https://en.wikipedia.org/wiki/Dennis_Ritchie" target="_blank" rel="external">Dennis Ritchie</a> 的逝世四周年的日子,没有他就没有Linux,BSD和我们爱的Mac OS.人们总是把低调的Dennis和传奇的乔布斯放在一起比较. 因为苹果,乔帮主家喻户晓,但没有多少人记得和乔帮主同年逝世的Dennis. 然而对于计算机发展史来讲,乔帮主的贡献不能与Dennis同日而语.</p>
<p>以此为敬.</p>
<h1 id="和Unix的手足之情"><a href="#和Unix的手足之情" class="headerlink" title="和Unix的手足之情"></a>和Unix的手足之情</h1><p>Unix 的原始版本是用汇编写的. 当Dennis Ritchie大叔在1973年缔造了C语言<br>之后,他和 Ken Thompson一起 (同是Unix的开发者)用C重写了kernel. 这也证明了即使不用汇编也可以写出low-level的操作系统.除此之外,由于C语言是可移植的,当可以产生object code 的C compiler被写出来的时候,说明在任何一个机器上都可以编译出可以运行在这台机器上的Unix 内核.从此可移植的操作系统就诞生了. ( 额外还需要一点customization和一些汇编来具体部署)<br><a id="more"></a></p>
<h1 id="相见恨晚"><a href="#相见恨晚" class="headerlink" title="相见恨晚"></a>相见恨晚</h1><p>没有建立一个很好的debugging习惯一直是我的一个遗憾. 总是靠无规律可言的方法通过printf等输出 来人肉debug. 但不稳定的模式往往是不靠谱的,至少它不能保证平均效率.</p>
<p>在期中考试的前一天抽空学了一把GDB,顺便把GCC一些特性温习了一遍. 总结在这里</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常回C看看&quot;&gt;&lt;a href=&quot;#常回C看看&quot; class=&quot;headerlink&quot; title=&quot;常回C看看.&quot;&gt;&lt;/a&gt;常回C看看.&lt;/h1&gt;&lt;p&gt;当你整天写python, ruby 等脚本语言 甚至一些越来越像lambda calculus的declarative language时候.( 以及同样有CG机制的不讨很多人喜欢的Java时), 你可能越来越像一个称职的”software” engineer instead of a hardware engineer. 足够抽象的语言将你从同机器的傻瓜式繁琐对话中解放出来,变成同人类或者智能机器的对话.将更多的精力集中在算法和模式思考上.&lt;br&gt;操作系统变得看不见摸不着,不需要再自己处理memory allocation 和memory collection, 不需要精心计算how much memory i need. 远观的确美,但其实也少了些xie玩的乐趣.&lt;/p&gt;
&lt;p&gt;随着C++11 Java8都开始引入风靡的lambda时,别忘记老当益壮的C老爹. &lt;/p&gt;
&lt;p&gt;常回C看看. &lt;/p&gt;
&lt;p&gt;这个月12号是C语言之父&lt;a href=&quot;https://en.wikipedia.org/wiki/Dennis_Ritchie&quot;&gt;Dennis Ritchie&lt;/a&gt; 的逝世四周年的日子,没有他就没有Linux,BSD和我们爱的Mac OS.人们总是把低调的Dennis和传奇的乔布斯放在一起比较. 因为苹果,乔帮主家喻户晓,但没有多少人记得和乔帮主同年逝世的Dennis. 然而对于计算机发展史来讲,乔帮主的贡献不能与Dennis同日而语.&lt;/p&gt;
&lt;p&gt;以此为敬.&lt;/p&gt;
&lt;h1 id=&quot;和Unix的手足之情&quot;&gt;&lt;a href=&quot;#和Unix的手足之情&quot; class=&quot;headerlink&quot; title=&quot;和Unix的手足之情&quot;&gt;&lt;/a&gt;和Unix的手足之情&lt;/h1&gt;&lt;p&gt;Unix 的原始版本是用汇编写的. 当Dennis Ritchie大叔在1973年缔造了C语言&lt;br&gt;之后,他和 Ken Thompson一起 (同是Unix的开发者)用C重写了kernel. 这也证明了即使不用汇编也可以写出low-level的操作系统.除此之外,由于C语言是可移植的,当可以产生object code 的C compiler被写出来的时候,说明在任何一个机器上都可以编译出可以运行在这台机器上的Unix 内核.从此可移植的操作系统就诞生了. ( 额外还需要一点customization和一些汇编来具体部署)&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>邂逅Fibonacci</title>
    <link href="http://yoursite.com/2015/10/24/fibonacci/"/>
    <id>http://yoursite.com/2015/10/24/fibonacci/</id>
    <published>2015-10-24T10:05:31.000Z</published>
    <updated>2017-01-04T13:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="魅力永恒的斐波那契"><a href="#魅力永恒的斐波那契" class="headerlink" title="魅力永恒的斐波那契"></a>魅力永恒的斐波那契</h1><p>天朝的同学们第一次学习斐波那契总跟那些繁殖力惊人的兔子脱不开干系.当然在达尔文进化论统治的空间里这是不现实的,除非在一个自建生态系统的初始阶段. </p>
<p>斐波那契的第一个研究者是将近一千年前的意大利数学家Leonardo(是的,和小李子同名)Fibonacci,它的魅力在于很多优美的性质,比如相邻斐波那契数想除的商会逐渐逼近黄金比例(我不知道为什么人们都觉得黄金分隔比是美的,然而确实就是这么觉得,身在宇宙中大概天生遵守一些法则),奇数项和,偶数项和,和天然植物,蜂巢的关系… 一切都惊人般的和谐.  </p>
<p>Then let’s get down to business.</p>
<h1 id="求解优化"><a href="#求解优化" class="headerlink" title="求解优化"></a>求解优化</h1><p>如果斐波那契先生在梦里问了你一个问题,第n个斐波那契是什么?</p>
<p>As simple and elegant as it sounds.</p>
<p>相信你不好意思说我在您一千年之后还不会解吧.当然,你可以说 啊,不如我们来谈谈star war……<br><a id="more"></a></p>
<h2 id="O-2-n"><a href="#O-2-n" class="headerlink" title="O(2^n)"></a>O(2^n)</h2><p>斐波那契是dynamic programming 方法的经典案例之一,第一反应自然是recursion.正如它的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f(0)=1</div><div class="line">f(1)=1</div><div class="line">for n&gt;=2 f(n) = f(n-1)+f(n-2)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#using python</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">if</span> n==<span class="number">0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span></div><div class="line">	<span class="keyword">elif</span> n==<span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> fibonacci(n<span class="number">-1</span>)+fibonacci(n<span class="number">-2</span>)</div></pre></td></tr></table></figure>
<p>最自然的解法.然而时间复杂度是O(2^n)很慢,因为把其他事情都丢给计算机去做了,只是把定义转义了一下.<br>为什么很慢,当call f(n) = f(n-1)+f(n-2) 会分头去计算f(n-1),f(n-2) 而f(n-1)会用到 f(n-2), f(n-1)和f(n-2)都会用到f(n-3),所有计算的中间结果都被浪费掉了.巨人的肩膀就在那里,偏偏要自己从头再来. 想起&lt;&lt;三体&gt;&gt; 中的乱纪元,如果当所有恒纪元中积累的文明都被摧毁,下一个乱纪元一切都会重头再来.从这一点上来看,人类是幸运的.n越小的因子被重复计算的次数越多</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">F(6)                 *  </div><div class="line">F(5)                 *  </div><div class="line">F(4)                 ** </div><div class="line">F(3)                ****</div><div class="line">F(2)              ********</div><div class="line">F(1)          ****************           &lt;-- 16</div><div class="line">F(0)  ********************************    &lt;-- 32</div></pre></td></tr></table></figure>
<p>被计算的次数在指数性增长.得到一棵深度为n-1的树.</p>
<h2 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h2><p>那么我要站在巨人的肩膀上,把文明通过历史的方式流传下去. 也就是要把计算结果储存起来,避免重复计算, 只有n个数,那我需要一个长度为n的list.<br>这同时也是 DP的bottom-up 的形式,从底层算起,直至找到目标.<br>可以写成一个for-loop 这样还可以避免递归function call的损耗</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></div><div class="line">	fibs = []</div><div class="line">	fibs.append(<span class="number">0</span>)</div><div class="line">	fibs.append(<span class="number">1</span>)</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</div><div class="line">		fibs.append(fibs[i<span class="number">-1</span>]+fibs[i<span class="number">-2</span>])</div><div class="line">		</div><div class="line">	<span class="keyword">return</span> fibs[n]</div></pre></td></tr></table></figure>
<p>也可以top-down递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">beauty</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n)</span>:</span></div><div class="line">		self.fibs = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n+<span class="number">1</span>)]</div><div class="line">		self.n = n</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(self,n)</span>:</span></div><div class="line">		<span class="keyword">if</span> self.fibs[n]!=<span class="number">-1</span> :</div><div class="line">			<span class="keyword">return</span> fibs[n]</div><div class="line">	</div><div class="line">		<span class="keyword">if</span> n==<span class="number">0</span>:</div><div class="line">			fibs[n]=<span class="number">0</span></div><div class="line">		<span class="keyword">elif</span> n==<span class="number">1</span>:</div><div class="line">			fibs[n]=<span class="number">1</span></div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			fibs[n] = fibonacci(n<span class="number">-1</span>)+fibs(n<span class="number">-2</span>)</div><div class="line">	</div><div class="line">		<span class="keyword">return</span> fibs[n]</div></pre></td></tr></table></figure>
<p>在巨人的肩膀上,轻松得到了linear time complexity.</p>
<p>还可以再优化吗?</p>
<p>看一下需求,斐波那契先生只问你第n个数是什么,没有问你从第一个到第n个是哪些数, 也就是说你的工作结果超过了他的需求(…不要类比产品经理,因为斐波那契比我们更懂斐波那契),那么其他的结果,你算出的哪些f(5),f(9),..f(n-3) 从”最理想” 的角度看都是被浪费的. 有连续性的一座桥可以过河,有离散分布的鹅卵石也可以过河 ( 不排除人家裘千仞连鹅卵石都不需要就可以过河 ).也就是说,除了计算结果的必由之路都是可以省略的,(不过这个必由之路恐怕就是 casewise的了).</p>
<p>计算机计算乘法和加法的时间并没有很大影响,那么怎样优化用乘法呢?</p>
<h1 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log n )"></a>O(log n )</h1><p>有一个我很喜欢的matrix A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[1,1]</div><div class="line">,[1,0]]</div></pre></td></tr></table></figure>
<p>这是一个通向未来又记录过去的matrix</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[f(n),f(n-1)         [[1,1]   [[f(n) + f(n-1), f(n)]</div><div class="line">,f(n-1),f(n-2)]]  *  ,[1,0]] = ,[f(n-1)+f(n-2),f(n-1)]</div></pre></td></tr></table></figure>
<p>不断地乘以 这个matrix 会得到斐波那契增长.<br>同时,我们得到了乘方!</p>
<p>f(n) = A^n [0][0]</p>
<p>不再想要每步线性增长,而希望得到指数增长,(也就是增大步长,用现有最大资源来作为步长前进),对乘法来说的现有最大资源就是乘以它自己, here comes matrix exponential</p>
<p>如果n%2==0 n = (n/2)+(n/2)<br>A^n = (A^(n/2))^2<br>如果n%2==1 n = 1+(n-1), 替换到下个偶数即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_power</span><span class="params">(A,n)</span>:</span></div><div class="line">	<span class="keyword">if</span> n==<span class="number">0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span></div><div class="line">	<span class="keyword">if</span> n==<span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> A</div><div class="line">	<span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> A*matrix_power(A,n<span class="number">-1</span>)</div><div class="line">	</div><div class="line">	B = matrix_power(A,n/<span class="number">2</span>)</div><div class="line">	<span class="keyword">return</span> B*B</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">if</span> n==<span class="number">0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span></div><div class="line">	<span class="keyword">if</span> n==<span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span></div><div class="line">	A = np.matrix([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]])</div><div class="line">	<span class="keyword">return</span> matrix_power(A,n<span class="number">-1</span>)[<span class="number">0</span>,<span class="number">0</span>]</div></pre></td></tr></table></figure>
<h1 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h1><p>space-time balance 是一个永远的权衡. 时间的节约很大程度上来源于我们提前将那些需要重复计算的值存储下来,用的时候只需要constant的access time.<br>这个叫做precomputation.  </p>
<p>传说鱼儿的记忆只有七秒,那么它生命应该是浪费了大量的时间来重复计算和重复思考.   </p>
<p>就像这样,你端起酒杯走向一个人准备请ta喝一杯,走到身前的时候完全忘记为什么站在这里,于是走回自己喜爱的座位.片刻之后,发现那边有个人,我想去请ta喝一杯. 然后you get into an infinite loop. </p>
<p>在这期间 John Nash 教授想出了博弈论 …. ( Credit to movie <em>A beautiful mind</em> ) </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;魅力永恒的斐波那契&quot;&gt;&lt;a href=&quot;#魅力永恒的斐波那契&quot; class=&quot;headerlink&quot; title=&quot;魅力永恒的斐波那契&quot;&gt;&lt;/a&gt;魅力永恒的斐波那契&lt;/h1&gt;&lt;p&gt;天朝的同学们第一次学习斐波那契总跟那些繁殖力惊人的兔子脱不开干系.当然在达尔文进化论统治的空间里这是不现实的,除非在一个自建生态系统的初始阶段. &lt;/p&gt;
&lt;p&gt;斐波那契的第一个研究者是将近一千年前的意大利数学家Leonardo(是的,和小李子同名)Fibonacci,它的魅力在于很多优美的性质,比如相邻斐波那契数想除的商会逐渐逼近黄金比例(我不知道为什么人们都觉得黄金分隔比是美的,然而确实就是这么觉得,身在宇宙中大概天生遵守一些法则),奇数项和,偶数项和,和天然植物,蜂巢的关系… 一切都惊人般的和谐.  &lt;/p&gt;
&lt;p&gt;Then let’s get down to business.&lt;/p&gt;
&lt;h1 id=&quot;求解优化&quot;&gt;&lt;a href=&quot;#求解优化&quot; class=&quot;headerlink&quot; title=&quot;求解优化&quot;&gt;&lt;/a&gt;求解优化&lt;/h1&gt;&lt;p&gt;如果斐波那契先生在梦里问了你一个问题,第n个斐波那契是什么?&lt;/p&gt;
&lt;p&gt;As simple and elegant as it sounds.&lt;/p&gt;
&lt;p&gt;相信你不好意思说我在您一千年之后还不会解吧.当然,你可以说 啊,不如我们来谈谈star war……&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="fibonacci" scheme="http://yoursite.com/tags/fibonacci/"/>
    
  </entry>
  
  <entry>
    <title>GDB 7.7版本以上OSO archive file问题</title>
    <link href="http://yoursite.com/2015/10/21/gdb-upgrade/"/>
    <id>http://yoursite.com/2015/10/21/gdb-upgrade/</id>
    <published>2015-10-21T11:04:10.000Z</published>
    <updated>2017-01-04T13:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="尚未解决"><a href="#尚未解决" class="headerlink" title="尚未解决"></a>尚未解决</h1><p>用homebrew 直接install了最新版本的gdb(7.10),在用来debug的时候却遭遇了问题.<br>可以打断点,但是run 会出现如下的warning</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">warning: Could not open OSO archive file <span class="string">"/BinaryCache/corecrypto/corecrypto-233.1.2~26/Symbols/BuiltProducts/libcorecrypto_static.a"</span></div><div class="line">warning: `/BinaryCache/coreTLS/coreTLS-35.1.2~1/Objects/coretls.build/coretls.build/Objects-normal/x86_64/system_coretls_vers.o<span class="string">': can'</span>t open to <span class="built_in">read</span> symbols: No such file or directory.</div><div class="line">warning: Could not open OSO archive file <span class="string">"/BinaryCache/coreTLS/coreTLS-35.1.2~1/Symbols/BuiltProducts/libcoretls_ciphersuites.a"</span></div><div class="line">warning: Could not open OSO archive file <span class="string">"/BinaryCache/coreTLS/coreTLS-35.1.2~1/Symbols/BuiltProducts/libcoretls_handshake.a"</span></div><div class="line">warning: Could not open OSO archive file <span class="string">"/BinaryCache/coreTLS/coreTLS-35.1.2~1/Symbols/BuiltProducts/libcoretls_record.a"</span></div><div class="line">warning: Could not open OSO archive file <span class="string">"/BinaryCache/coreTLS/coreTLS-35.1.2~1/Symbols/BuiltProducts/libcoretls_stream_parser.a"</span></div></pre></td></tr></table></figure>
<p>google了一番, 这个问题尚未得到解决,在github上被推成upstream问题,可以去<a href="https://github.com/Homebrew/homebrew-dupes/issues/357" target="_blank" rel="external">这里</a>看这个问题讨论,可以subscribe等待之后的解决情况.</p>
<p>如果还想用gdb只有downgrade回去7.7版本了</p>
<h1 id="brew-install-old-version-of-gdb"><a href="#brew-install-old-version-of-gdb" class="headerlink" title="brew install old version of gdb"></a>brew install old version of gdb</h1><p>它的ruby脚本在<a href="https://gist.github.com/ymyzk/10ad2b74af9235eddb2c" target="_blank" rel="external">这里</a></p>
<p>可以直接如下安装 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install https://gist.githubusercontent.com/ymyzk/10ad2b74af9235eddb2c/raw/9d0b9734ea01f9753a5f54dd221acd99ee7e53e8/gdb.rb</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;尚未解决&quot;&gt;&lt;a href=&quot;#尚未解决&quot; class=&quot;headerlink&quot; title=&quot;尚未解决&quot;&gt;&lt;/a&gt;尚未解决&lt;/h1&gt;&lt;p&gt;用homebrew 直接install了最新版本的gdb(7.10),在用来debug的时候却遭遇了问题.&lt;br&gt;可以打断点
    
    </summary>
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>CRLF vs LF</title>
    <link href="http://yoursite.com/2015/10/04/bairixing/"/>
    <id>http://yoursite.com/2015/10/04/bairixing/</id>
    <published>2015-10-04T06:06:14.000Z</published>
    <updated>2017-01-04T13:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows-Unix-line-ending"><a href="#Windows-Unix-line-ending" class="headerlink" title="Windows/Unix line ending"></a>Windows/Unix line ending</h2><p>最近在帮金融系的教授做研究助理,帮教授写程序.有编程基础的教授化身产品经理的模样,不断地抛出需求.我要做的就是为教授的金融模型或者理论做大量的数据处理,于是写了不少python和shell scprits. 有时教授会形成习惯了甚至把我当IT使用,死机窗口卡顿的时候呼唤我…..不过被信任还是很荣幸的.  </p>
<p>然而出现了这样一个问题.  </p>
<p>我在 Mac上写好的shell script并且写过小测试试了下发给教授,教授run的时候却出现syntax error,could not find expecting…bla bla…    </p>
<p>第一个反应当然是自我怀疑地重新run了我本地的script.Bam! Nothing is wrong!然后怀疑教授,让教授重新下载脚本重run. The same problem…..然后我就和见鬼了一样看着两台机子上的script大致比对…”shell不可能有indentation的问题啊…then what’s wrong? “,然后我想到那些诡异的隐藏符,比如换行之类的,然后快速在教授机子上重写了一遍script,save it and run. Went smoothly as expected.     </p>
<p>一个肉眼不可见的问题,我想起了那些诡异的隐藏符.那么可能就是操作系统带来的差别,我查了mac本地的文件类型是unix.<br><a id="more"></a></p>
<p>Cited from stackoverflow</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">From samjudson:  </div><div class="line">&gt;This is only a difference in text files, where UNIX uses a single Line Feed (LF) to signify a new line, Windows uses a Carriage Return/Line Feed (CRLF) and Mac uses just a CR. </div><div class="line"> </div><div class="line"> </div><div class="line"> Cebjyre elaborates:  </div><div class="line"></div><div class="line">&gt; OS X uses LF, the same as UNIX - MacOS 9 and below did use CR though.</div></pre></td></tr></table></figure>
<h2 id="Found-our-Murderer"><a href="#Found-our-Murderer" class="headerlink" title="Found our Murderer"></a>Found our Murderer</h2><p>在不同的机器上写出的text file的line ending是不同的,windos/dos 机上为”\r\n”,而Unix/Linux 只有”\n”.  </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">unix	</div><div class="line"><span class="code">	LF only (each line ends with an LF character).  </span></div><div class="line"><span class="section">	Unix based systems and Mac OS X and later.</span></div><div class="line">---</div><div class="line">dos</div><div class="line"><span class="code">	CRLF (each line ends with CR then LF).   </span></div><div class="line"><span class="code">	DOS and Windows.  </span></div><div class="line">---	</div><div class="line">mac</div><div class="line"><span class="code">	CR only (each line ends with a CR character).  </span></div><div class="line"><span class="code">	Mac OS version 9 and earlier</span></div><div class="line"><span class="code">	later becomes LF</span></div><div class="line"><span class="code">	</span></div><div class="line">CR is carriage return (return cursor to left margin), which is Ctrl-M or ^M or hex 0D.</div><div class="line"></div><div class="line">LF is linefeed (move cursor down), which is Ctrl-J or ^J or hex 0A. Sometimes, LF is written as NL (newline).</div></pre></td></tr></table></figure>
<h2 id="Conversion-between-CRLF-and-Just-line-feed"><a href="#Conversion-between-CRLF-and-Just-line-feed" class="headerlink" title="Conversion between CRLF and Just line feed"></a>Conversion between CRLF and Just line feed</h2><ol>
<li><p>查找替换.<br> 这是最直觉的方法.可以利用自己偏好的Editor查找替换,或者用一些智能的功能.<br> 比如在Vim里可以用:set ff?来查看fileformat. 这里的ff(fileformat 的缩写)是局限于当前buffer的,当文件被读入的时候被Vim赋值,或者可以在command line中指定,fileformat决定了buffer怎样读入一个文件(包括对line ending进行相应的修改),以及可以通过改变fileformat的值对buffer写文件的格式进行修改 :set fileformat=dos/unix/mac  </p>
<p> 同时还有一个fifleformats的全局选项,是在没有特殊指定的时候vim将按照这些顺序去read这个文件,在mac上会显示fileformats=unix,dos<br>文件格式的问题会出现^M的乱码,用:e ++ff=dos 去掉.<br>手动的话可以:%s/^V^M//g   </p>
<p> 还有一种看到的办法是(未亲测)Notepad++ Edit -&gt; EOL Conversion 里面有已经准备好的选项可以用 </p>
<p> 然而简单的查找替换的速度有限,在文件不大的时候可以考虑</p>
</li>
</ol>
<ol>
<li><p>现有工具    </p>
<ul>
<li>可以用FTP, 在传输之前先敲ascii,会被转换成ascii文件格式,当传到另一个host上时会用合适于它的的格式打开</li>
<li><p>dos2unix 和 unix2dos, 在unix平台上装上可以使用</p>
<pre><code>dos2unix winfile.txt unixfile.txt

unix2dos unixfile.txt winfile.txt
</code></pre></li>
<li><p>还有一些脚本方法,没有试过,暂时写在这里</p>
<pre><code># 只可以转unix
  tr -d &apos;\15\32&apos; &lt; winfile.txt &gt; unixfile.txt
</code></pre></li>
</ul>
</li>
</ol>
<pre><code># awk
  awk &apos;{ sub(&quot;\r$&quot;, &quot;&quot;); print }&apos; winfile.txt &gt; unixfile.txt
  awk &apos;sub(&quot;$&quot;, &quot;\r&quot;)&apos; unixfile.txt &gt; winfile.txt

# perl
  perl -p -e &apos;s/\r$//&apos; &lt; winfile.txt &gt; unixfile.txt 
  perl -p -e &apos;s/\n/\r\n/&apos; &lt; unixfile.txt &gt; winfile.txt
</code></pre><ol>
<li>A simple trick<br>直接拖进chrome/firefox 然后剪切粘贴即可以解决这个问题……仿佛看到了一位生活小能手的同学</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Windows-Unix-line-ending&quot;&gt;&lt;a href=&quot;#Windows-Unix-line-ending&quot; class=&quot;headerlink&quot; title=&quot;Windows/Unix line ending&quot;&gt;&lt;/a&gt;Windows/Unix line ending&lt;/h2&gt;&lt;p&gt;最近在帮金融系的教授做研究助理,帮教授写程序.有编程基础的教授化身产品经理的模样,不断地抛出需求.我要做的就是为教授的金融模型或者理论做大量的数据处理,于是写了不少python和shell scprits. 有时教授会形成习惯了甚至把我当IT使用,死机窗口卡顿的时候呼唤我…..不过被信任还是很荣幸的.  &lt;/p&gt;
&lt;p&gt;然而出现了这样一个问题.  &lt;/p&gt;
&lt;p&gt;我在 Mac上写好的shell script并且写过小测试试了下发给教授,教授run的时候却出现syntax error,could not find expecting…bla bla…    &lt;/p&gt;
&lt;p&gt;第一个反应当然是自我怀疑地重新run了我本地的script.Bam! Nothing is wrong!然后怀疑教授,让教授重新下载脚本重run. The same problem…..然后我就和见鬼了一样看着两台机子上的script大致比对…”shell不可能有indentation的问题啊…then what’s wrong? “,然后我想到那些诡异的隐藏符,比如换行之类的,然后快速在教授机子上重写了一遍script,save it and run. Went smoothly as expected.     &lt;/p&gt;
&lt;p&gt;一个肉眼不可见的问题,我想起了那些诡异的隐藏符.那么可能就是操作系统带来的差别,我查了mac本地的文件类型是unix.&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="os" scheme="http://yoursite.com/tags/os/"/>
    
  </entry>
  
</feed>
